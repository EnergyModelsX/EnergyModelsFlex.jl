var documenterSearchIndex = {"docs":
[{"location":"nodes/network/activationcostnode/#nodes-activationcostnode","page":"ActivationCostNode","title":"ActivationCostNode","text":"ActivationCostNode is a specialized NetworkNode that introduces unit commitment logic with additional fuel or resource costs incurred upon startup. It models technologies that consume extra input when switching on, such as combustion turbines or thermal boilers.\n\nwarning: Limitations in its current version\nThe node does not allow for part-load operation.\nThe node does not allow for investments.\n\ntip: Use cases\nThis node is useful when modeling generation or conversion units that consume startup fuel, such as gas turbines, diesel generators, or heating systems with preheat requirements.","category":"section"},{"location":"nodes/network/activationcostnode/#nodes-activationcostnode-fields","page":"ActivationCostNode","title":"Introduced type and its fields","text":"The ActivationCostNode extends the standard NetworkNode by incorporating binary unit commitment variables and explicit activation costs in the form of additional input resource usage during startup.","category":"section"},{"location":"nodes/network/activationcostnode/#nodes-activationcostnode-fields-stand","page":"ActivationCostNode","title":"Standard fields","text":"The standard fields are given as:\n\nid:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal capacity of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified input and output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of an investment period as outlined on Utilize TimeStruct.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\ninput::Dict{<:Resource,<:Real} and output::Dict{<:Resource,<:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries.\nCO‚ÇÇ cannot be directly specified, i.e., you cannot specify a ratio. If you use CaptureData, it is however necessary to specify CO‚ÇÇ as output, although the ratio is not important.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is used for providing EmissionsData.\nnote: Constructor for `ActivationCostNode`\nThe field data is not required as we include a constructor when the value is excluded.\nwarning: Using `CaptureData`\nIf you plan to use CaptureData for an ActivationCostNode node, it is crucial that you specify your CO‚ÇÇ resource in the output dictionary. The chosen value is however not important as the CO‚ÇÇ flow is automatically calculated based on the process utilization and the provided process emission value. The reason for this necessity is that flow variables are declared through the keys of the output dictionary. Hence, not specifying CO‚ÇÇ as output resource results in not creating the corresponding flow variable and subsequent problems in the design.We plan to remove this necessity in the future. As it would most likely correspond to breaking changes, we have to be careful to avoid requiring major changes in other packages.\n\nwarning: Compatible time structure\nNote that this node cannot be used with OperationalScenarios or RepresentativePeriods.","category":"section"},{"location":"nodes/network/activationcostnode/#nodes-activationcostnode-fields-new","page":"ActivationCostNode","title":"Additional fields","text":"ActivationCostNode nodes add two additional fields compared to a NetworkNode:\n\nactivation_time::Real:\nDuration of activation effect (currently used to inform activation logic in customized formulations). This field is currently not utilized.\nactivation_consumption::Dict{<:Resource,<:Real}:\nRequired consumption of the input resources when the node switches on. Note that the value is the absolute required value and the resource must be included in the input dictionary.","category":"section"},{"location":"nodes/network/activationcostnode/#nodes-activationcostnode-math","page":"ActivationCostNode","title":"Mathematical description","text":"ActivationCostNode introduces startup-aware constraints and binary control variables, alongside the standard flow and cost formulations of NetworkNodes.","category":"section"},{"location":"nodes/network/activationcostnode/#nodes-activationcostnode-math-var","page":"ActivationCostNode","title":"Variables","text":"In addition to common variables:\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data\n\nthe following binary variables are defined for unit commitment logic:\n\ntexttton_offn t in 01:\nBinary status indicator for whether the unit is active in time period t.\ntextttonswitchn t in 01:\nIndicates that the unit is being turned on in time period t.\ntextttoffswitchn t in 01:\nIndicates that the unit is being turned off in time period t.","category":"section"},{"location":"nodes/network/activationcostnode/#nodes-activationcostnode-math-con","page":"ActivationCostNode","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of ActivationCostNode nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all ActivationCostNode types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/network/activationcostnode/#nodes-activationcostnode-math-con-stand","page":"ActivationCostNode","title":"Standard constraints","text":"ActivationCostNodes utilize in general the standard constraints that are implemented for a NetworkNode node as described in the documentation of EnergyModelsBase. These standard constraints are:\n\nconstraints_flow_out:\ntextttflow_outn t p =\noutputs(n p) times textttcap_usen t\nqquad forall p in outputs(n) setminus textCO_2\nconstraints_opex_fixed:\ntextttopex_fixedn t_inv = opex_fixed(n t_inv) times textttcap_instn first(t_inv)\ntip: Why do we use `first()`\nThe variable textttcap_inst is declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacity in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\ntextttopex_varn t_inv = sum_t in t_inv opex_var(n t) times textttcap_usen t times scale_op_sp(t_inv t)\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified data of the nodes, see above.\n\nThe functions constraints_capacity is extended with  a new method to calculate the on-off switching. The consistency across time is provided by the following constraint\n\ntexttton_offn t =\ntexttton_offn t_prev - textttoffswitchn t + textttonswitchn t\n\nFor the first time step in each investment period, the last value of the previous period is used instead of t_prev.\n\ntextttoffswitchn t + textttonswitchn t leq 0\n\nThe operational usage of the node is limited by the variable texttton_offn t\n\ntextttcap_usen t = texttton_offn t times capacity(n t)\n\nand the installed capacity through the variable textttcap_instn t\n\ntextttcap_usen t leq textttcap_instn t\n\nAs we want to avoid bilinearities and have not implemented the linear reformulation, we furthermore constrain the function installed capacity to the provided capacity in this function.\n\ntextttcap_instn t = capacity(n t)\n\nwarning: Investments\nAs we do not call the function constraints_capacity_installed, we do not allow for investments in this node type.\n\nThe function constraints_flow_in is extended with a new method to account for the additional consumption:\n\ntextttflow_inn t p =\ninputs(n p) times textttcap_usen t +\nactivation_consumption(n p) times textttonswitchn t\n\nThis models additional startup consumption, e.g., diesel or gas during ignition or ramp-up.\n\nnote: Activation logic\nThe field activation_time is not directly included in the constraint equations above but can be used in more advanced formulations where startup effects extend beyond a single time step.\n\nwarning: Binary complexity\nSimilar to MinUpDownTimeNode, this node is a mixed-integer formulation and increases the complexity of the optimization model.","category":"section"},{"location":"how-to/contribute/#how_to-con","page":"Contribute","title":"Contribute to EnergyModelsFlex","text":"Contributing to EnergyModelsFlex can be achieved in several different ways.","category":"section"},{"location":"how-to/contribute/#how_to-con-bug_rep","page":"Contribute","title":"File a bug report","text":"An approach to contributing to EnergyModelsFlex is through filing a bug report as an issue when unexpected behaviour is occuring.\n\nWhen filing a bug report, please follow the following guidelines:\n\nBe certain that the bug is a bug and originating in EnergyModelsFlex:\nIf the problem is within the results of the optimization problem, please check first that the nodes are correctly linked with each other. Frequently, missing links (or wrongly defined links) restrict the transport of energy/mass. If you are certain that all links are set correctly, it is most likely a bug in EnergyModelsFlex and should be reported.\nIf the problem occurs in model construction, it is most likely a bug in either EnergyModelsBase or EnergyModelsFlex and should be reported in the respective package. The error message of Julia should provide you with the failing function and whether the failing function is located in EnergyModelsBase or EnergyModelsFlex. It can occur, that the last shown failing function is within JuMP or MathOptInterface. In this case, it is best to trace the error to the last called EnergyModelsBase or EnergyModelsFlex function.\nIf the problem is only appearing for specific solvers, it is most likely not a bug in EnergyModelsFlex, but instead a problem of the solver wrapper for MathOptInterface. In this case, please contact the developers of the corresponding solver wrapper.\nLabel the issue as bug, and\nProvide a minimum working example of a case in which the bug occurs.","category":"section"},{"location":"how-to/contribute/#how_to-con-feat_req","page":"Contribute","title":"Feature requests","text":"Feature requests for EnergyModelsFlex should follow the guidelines developed for EnergyModelsBase.\n\ntip: Development of new types and functionality\nIn general, new types or functionality are best tested by implementing them in a package in which they are required. In this case, if you believe that these new types or functionality may be relevant for several other packages, we ask you to create an issue witha link to the implementation,\na description of its benefits, and\nideas regarding the implementation.It is crucial that provided tests work without having to load a different package. This can be achieved through types that are only introduced in the testsets.","category":"section"},{"location":"library/internals/types/#lib-int-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"library/internals/types/#lib-int-types-idx","page":"Types","title":"Index","text":"Pages = [\"types.md\"]","category":"section"},{"location":"library/internals/types/#lib-int-types-node_link","page":"Types","title":"Nodal supertypes","text":"","category":"section"},{"location":"library/internals/types/#EnergyModelsFlex.UnitCommitmentNode","page":"Types","title":"EnergyModelsFlex.UnitCommitmentNode","text":"UnitCommitmentNode{} <: EMB.NetworkNode\n\nAbstract type for unit commitment nodes.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types/#EnergyModelsFlex.AbstractPeriodDemandSink","page":"Types","title":"EnergyModelsFlex.AbstractPeriodDemandSink","text":"abstract type AbstractPeriodDemandSink <: EMB.Sink\n\nSupertypes for period demand sinks in which the demand must be satisifed within a given period.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types/#EnergyModelsFlex.AbstractMultipleInputSink","page":"Types","title":"EnergyModelsFlex.AbstractMultipleInputSink","text":"abstract type AbstractMultipleInputSink <: Sink\n\nAbstract supertype for Sink nodes in which the demand can be satisfied by multiple resources.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types/#EnergyModelsFlex.AbstractMultipleInputSinkStrat","page":"Types","title":"EnergyModelsFlex.AbstractMultipleInputSinkStrat","text":"abstract type AbstractMultipleInputSinkStrat <: AbstractMultipleInputSink\n\nAbstract supertype for AbstractMultipleInputSink nodes in which the ratio between the different resources must be constant within a strategic period.\n\n\n\n\n\n","category":"type"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink","page":"PeriodDemandSink","title":"PeriodDemandSink node","text":"PeriodDemandSink nodes represent flexible demand sinks where demand must be fulfilled within defined periods (e.g. daily or weekly), rather than in each individual operational time step. A period is thus a consecutive range of operational periods, that together will model, e.g., a day or a week etc.\n\nThis node can, e.g., be combined with MinUpDownTimeNode, to allow production to be moved to the time of the day when it is cheapest because of, e.g., energy or production costs.\n\ntip: Example\nThis node is included in an example to demonstrate flexible demand.\n\nwarning: TimeStructure for node\nThis node is designed for uniform or repetitive duration of operational periods. Irregular durations may cause misalignment of shifted loads, especially if the field period_length does not align with the chosen SimpleTimes structure representing the operational periods.","category":"section"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink-fields","page":"PeriodDemandSink","title":"Introduced type and its fields","text":"The PeriodDemandSink node extends the Sink functionality by introducing aggregated demand over fixed-length periods. This is useful for representing flexible loads like electric vehicle charging or industrial batch processes, where exact timing of delivery is flexible.\n\nnote: Abstract supertype\nPeriodDemandSink is defined as a subtype of AbstractPeriodDemandSink, and constraints are put on this supertype. By subtyping AbstractPeriodDemandSink, you can easily extend the functionality of this node.","category":"section"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink-fields-stand","page":"PeriodDemandSink","title":"Standard fields","text":"The standard fields are given as:\n\nid:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe maximum amount of demand that can be met in each operational period. This acts as a capacity on instantaneous delivery, while period_demand enforces total energy delivered within the chosen period.\npenalty::Dict{Symbol,<:TimeProfile}:\nThe penalty dictionary is used for providing penalties for soft constraints to allow for both over and under delivering the demand.\nIt must include the fields :surplus and :deficit. In addition, it is crucial that the sum of both values is larger than 0 to avoid an unconstrained model.\nwarning: Chosen values\nThe current implementation does not represent the proper cost due to the summation. Instead, you must consider the duration of an operational period and the field period_length when providing a value. In this case, the value should be multiplied by 1period_length(n) times duration(t).\ninput::Dict{<:Resource,<:Real}:\nThe field input includes Resources with their corresponding conversion factors as dictionaries.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used.\nnote: Included constructor\nThe field data is not required as we include a constructor when the value is excluded.\ndanger: Using `CaptureData`\nAs a Sink node does not have any output, it is not possible to utilize CaptureData. If you still plan to specify it, you will receive an error in the model building.\n\nnote: Note\nUnlike RefSink, the delivery of demand here is flexible within each demand period. This is helpful for modeling demand that can shift within a day or week.","category":"section"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink-fields-new","page":"PeriodDemandSink","title":"Additional fields","text":"AbstractPeriodDemandSinks require additional fields to specify both the periods and their respective demands:\n\nperiod_length::Int:\nDefines how many operational periods are included in a single demand period.\nFor instance, if the duration of the operational periods is 1 hour and period_length = 24, then each demand period spans one day. The demand of this node (for a given day, see below) must then be filled on a daily basis, without any restrictions on when during the day the demand must be filled.\nperiod_demand::Vector{<:Real}:\nThe total demand to be met during each demand period. The length of this vector should match the number of periods (e.g., days) in the time structure. If the time structure represents on year with hourly resolution, this vector must then have 365 elements.\nwarning: Time consistency\nEnsure that the period_demand vector length aligns with the total time horizon divided by period_length. Mismatches can lead to indexing errors or inconsistent demand enforcement.\n\nThese fields are at the 2‚Åø·µà and 3 ≥·µà position below the field id as shown in PeriodDemandSink.","category":"section"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink-math","page":"PeriodDemandSink","title":"Mathematical description","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as\n\ntextttvar_exampleindex_1 index_2\n\nwith square brackets, while functions are represented as\n\nfunc_example(index_1 index_2)\n\nwith paranthesis.","category":"section"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink-math-var","page":"PeriodDemandSink","title":"Variables","text":"","category":"section"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink-math-var-stand","page":"PeriodDemandSink","title":"Standard variables","text":"The PeriodDemandSink nodes utilize all standard variables from a Sink node, as described on the page Optimization variables. The variables include:\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttsink_surplus\ntextttsink_deficit\ntextttemissions_node if EmissionsData is added to the field data","category":"section"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink-math-add","page":"PeriodDemandSink","title":"Additional variables","text":"AbstractPeriodDemandSink nodes declare in addition several variables through dispatching on the method EnergyModelsBase.variables_element() for including constraints for deficits and surplus for individual resources as well as what the fraction satisfied by each resource. These variables are for a AbstractPeriodDemandSink node n in demand periods i:\n\ntextttdemand_sink_surplusn i:\nSurplus of energy delivered beyond the required period_demand in demand period i.\ntextttdemand_sink_deficitn i:\nDeficit of energy delivered relative to the period_demand in period i.","category":"section"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink-math-con","page":"PeriodDemandSink","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of AbstractPeriodDemandSink nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all AbstractPeriodDemandSink types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/sink/perioddemand/#nodes-perioddemandsink-math-con-stand","page":"PeriodDemandSink","title":"Standard constraints","text":"AbstractPeriodDemandSink utilize in general the standard constraints that are implemented for a Sink node as described in the documentaiton of EnergyModelsBase. These standard constraints are:\n\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_in:\ntextttflow_inn t p =\ninputs(n p) times textttcap_usen t\nqquad forall p in inputs(n)\ntip: Multiple inputs\nThe constrained above allows for the utilization of multiple inputs with varying ratios. it is however necessary to deliver the fixed ratio of all inputs.\nconstraints_opex_fixed:\nThe current implementation fixes the fixed operating expenses of a sink to 0.\ntextttopex_fixedn t_inv = 0\nconstraints_data:\nThis function is only called for specified additional data, see above.\n\nThe function constraints_capacity is extended with a new method to account for the calculation of the period demand deficit and surplus through:\n\ntextttcap_usen t + textttsink_deficitn t = textttcap_instn t + textttsink_surplusn t\n\nbeginaligned\ntextttdemand_sink_deficitn i +  sum_t in P_i textttcap_usent   = \n textttdemand_sink_surplusn i + period_demand(n i)\nendaligned\n\nwhere P_i is the set of operational periods in demand period i.\n\nAs a consequence, constraints_opex_var requires as well a new method as we only consider the deficit within a complete period:\n\nbeginaligned\ntextttopex_varn t_inv = sum_t  t_inv( textttdemand_sink_surplusn i_t times textttsurplus_penalty(n t) + \n textttdemand_sink_deficitn i_t times textttdeficit_penalty(n t)) times \n scale_op_sp(t_inv t)\nendaligned\n\nwhere i_t is the period index such that t in P_i_t.\n\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.","category":"section"},{"location":"nodes/network/flexibleoutput/#nodes-FlexibleOutput","page":"FlexibleOutput","title":"FlexibleOutput","text":"The FlexibleOutput node models a conversion technology that can produce multiple output resources while sharing a single capacity limit. In contrast to a standard NetworkNode, the utilized capacity is defined by the sum of all output flows, scaled by their respective output conversion factors.\n\nThis formulation enables flexible allocation of production across several co-products (e.g., multiple heat levels or energy carriers) while ensuring that total production remains consistent with the available capacity.","category":"section"},{"location":"nodes/network/flexibleoutput/#nodes-FlexibleOutput-fields","page":"FlexibleOutput","title":"Introduced type and its fields","text":"The FlexibleOutput is a subtype of the NetworkNode. It reuses all standard NetworkNode functionality except for the output-flow formulation, which is extended to allow flexible output composition.","category":"section"},{"location":"nodes/network/flexibleoutput/#nodes-FlexibleOutput-fields-stand","page":"FlexibleOutput","title":"Standard fields","text":"The standard fields of a FlexibleOutput node are given as:\n\nid:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal capacity of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified input and output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of an investment period as outlined on Utilize TimeStruct.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\ninput::Dict{<:Resource,<:Real} and output::Dict{<:Resource,<:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries.\nCO‚ÇÇ cannot be directly specified, i.e., you cannot specify a ratio. If you use CaptureData, it is however necessary to specify CO‚ÇÇ as output, although the ratio is not important.\nAll values have to be non-negative.\ntip: Conversion factor\nThe conversion factor for the input is used as a multiplier for the capacity usage. A value of 2 implies that you need 2 MW input resource/MW capacity usage.\nThe conversion factor for the output is also used as a multiplier for the capacity usage. A value of 2 implies that you produce 2 MW output resource/MW capacity usage. This implies that a higher value results in more production based on a given capacity. It is hence important to be careful when choosing values to avoid a perpetual motion machine.\ndata::Vector{<:ExtensionData}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used.\nnote: Constructor for `FlexibleOutput`\nThe field data is not required as we include a constructor when the value is excluded.\nwarning: Using `CaptureData`\nIf you plan to use CaptureData for a FlexibleOutput node, it is crucial that you specify your CO‚ÇÇ resource in the output dictionary. The chosen value is however not important as the CO‚ÇÇ flow is automatically calculated based on the process utilization and the provided process emission value. The reason for this necessity is that flow variables are declared through the keys of the output dictionary. Hence, not specifying CO‚ÇÇ as output resource results in not creating the corresponding flow variable and subsequent problems in the design.We plan to remove this necessity in the future. As it would most likely correspond to breaking changes, we have to be careful to avoid requiring major changes in other packages.","category":"section"},{"location":"nodes/network/flexibleoutput/#nodes-FlexibleOutput-math","page":"FlexibleOutput","title":"Mathematical description","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as\n\ntextttvar_exampleindex_1 index_2\n\nwith square brackets, while functions are represented as\n\nfunc_example(index_1 index_2)\n\nwith paranthesis.","category":"section"},{"location":"nodes/network/flexibleoutput/#nodes-FlexibleOutput-math-var","page":"FlexibleOutput","title":"Variables","text":"The FlexibleOutput node uses the standard NetworkNode optimization variables (see Optimization variables):\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttflow_out","category":"section"},{"location":"nodes/network/flexibleoutput/#nodes-FlexibleOutput-math-con","page":"FlexibleOutput","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of flexible output nodes. Instead, it is implicitly assumed that the constraints are valid forall n  ^FlexibleOutput for all FlexibleOutput types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all strategic periods).","category":"section"},{"location":"nodes/network/flexibleoutput/#nodes-FlexibleOutput-math-con-stand","page":"FlexibleOutput","title":"Standard constraints","text":"FlexibleOutput nodes utilize in general the standard constraints described on Constraint functions for NetworkNodes, except for the output-flow constraint.\n\nThe following standard constraints apply:\n\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_capacity:\ntextttcap_usen t leq textttcap_instn t\nconstraints_flow_in:\ntextttflow_inn t p = inputs(n p) times textttcap_usen t\nqquad forall p in inputs(n)\nconstraints_opex_fixed:\ntextttopex_fixedn t_inv = opex_fixed(n t_inv) times\ntextttcap_instn first(t_inv)\ntip: Why do we use `first()`\nThe variable textttcap_inst is declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacity in the first operational period of a given strategic period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\ntextttopex_varn t_inv = sum_t in t_inv\nopex_var(n t) times textttcap_usen t\ntimes scale_op_sp(t_inv t)\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and strategic periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_ext_data: This function is only called if extension data are specified for the node.\n\nThe function constraints_flow_out is extended with a new method for flexible output nodes such that the outputs are flexible within their sum being the capacity usage of the node.\n\nLet mathcalP^out(n) denote the set of output resources of node n excluding CO‚ÇÇ, obtained through the function soutputs. The implemented constraint is then given by\n\nsum_p in mathcalP^out(n) fractextttflow_outn t poutputs(n p) = textttcap_usen t","category":"section"},{"location":"nodes/network/flexibleoutput/#nodes-FlexibleOutput-math-con-add","page":"FlexibleOutput","title":"Additional constraints","text":"FlexibleOutput nodes do not introduce additional constraint functions beyond the flexible output-flow formulation described above.","category":"section"},{"location":"examples/flexible_demand/#examples-flexible_demand","page":"Flexible demand","title":"Flexible demand","text":"This example uses the following two nodes from EnergyModelsFlex:\n\nPeriodDemandSink to set a demand per day instead of per operational period and\nMinUpDownTimeNode to force the production to run for a minimum number of hours if it has first started, and be shut off for a minimum number of hours if it has first stopped.\n\nusing EnergyModelsBase\nusing EnergyModelsFlex\nusing TimeStruct\n\nusing HiGHS\nusing JuMP\nusing PrettyTables\n\nDeclare the required resources.\n\nPower = ResourceCarrier(\"Power\", 0)\nProduct = ResourceCarrier(\"Product\", 0)\nCO2 = ResourceEmit(\"CO2\", 0)\nùí´ = [Power, Product]\n\nDefine a timestructure for a single week. The week is modelled with hourly resolution.\n\nùíØ = TwoLevel(1, 1, SimpleTimes(7 * 24, 1))\n\nSome arbitrary electricity prices. Note we let the energy be free in the weekend. This would be a huge incentive to produce during the weekend, if we allowed the PeriodDemandSink capacity during the weekend.\n\nday = [1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2]\nel_cost = [repeat(day, 5)..., fill(0, 2 * 24)...]\n\ngrid = RefSource(\n    \"grid\",\n    FixedProfile(1e12), # kW - virtually infinite\n    OperationalProfile(el_cost),\n    FixedProfile(0),\n    Dict(Power => 1),\n)\n\nThe production can only run between 6-20 on weekdays, with a capacity of 300 kW. First, define the maximum capacity for a regular weekday (24 hours). The capacity is 0 between 0 am and 6 am, 300 kW between 6 am and 8 pm, and 0 again between 8 pm and midnight.\n\nweekday_prod = [fill(0, 6)..., fill(300, 14)..., fill(0, 4)...]\n@assert length(weekday_prod) == 24\n\nRepeat a weekday 5 times, for a workweek, then no production on the weekends.\n\nweek_prod = [repeat(weekday_prod, 5)..., fill(0, 2 * 24)...]\n\ndemand = PeriodDemandSink(\n    \"demand_product\",\n    24, # 24 hours per day.\n    [fill(1500, 5)..., 0, 0], # Demand of 1500 units per day, and nothing (0) in the weekend.\n    OperationalProfile(week_prod), # kW - installed capacity\n    Dict(:surplus => FixedProfile(0), :deficit => FixedProfile(1e8)), # ‚Ç¨ / Demand - Price for not delivering products\n    Dict(Product => 1),\n)\n\nDefine the production line using MinUpDownTimeNode\n\nmin_up_time = 8\nmin_down_time = 5\nline = MinUpDownTimeNode(\n    \"line\",\n    FixedProfile(300), # kW - installed capacity for both lines\n    FixedProfile(0),\n    FixedProfile(0),\n    Dict(Power => 1),\n    Dict(Product => 1),\n    min_up_time, # minUpTime\n    min_down_time, # minDownTime\n    50, # minCapacity\n    300, # maxCapacity\n    [],\n)\n\nDefine the simple energy system\n\nùí© = [grid, line, demand]\n‚Ñí = [Direct(\"grid-line\", grid, line), Direct(\"line-demand\", line, demand)]\ncase = Case(ùíØ, ùí´, [ùí©, ‚Ñí])\n\nDefine as operational energy model\n\nmodeltype = OperationalModel(\n    Dict(CO2 => FixedProfile(1e6)),\n    Dict(CO2 => FixedProfile(100)),\n    CO2,\n)\n\nOptimize the model\n\nm = run_model(case, modeltype, HiGHS.Optimizer)\n\nShow status, should be optimal\n\n@show termination_status(m)\n\nGet the full row table\n\ntable = JuMP.Containers.rowtable(value, m[:cap_use]; header = [:Node, :TimePeriod, :CapUse])\n\nFilter only for Node == line\n\nline = get_nodes(case)[2]\nfiltered = filter(row -> row.Node == line, table)\n\nDisplay the filtered table with the resulting optimal production.\n\nNote that the demand is only satisfied during the set workhours (6-20) on weekdays. This is cause by the restrictions put on PeriodDemandSink with the capacity limited to these time periods. This is also the reason that there is no production during the weekend, even though the electricity is free.\nAlso note that the production is always run for at least 8 hours, even though the daily demand of 1500 units could be reached in 5 hours running at full capacity. This can be explained by the constraint for minimum run time of 8 hours on the MinUpDownTimeNode. To maximize production at low prices, it runs at the minimum capacity of 50 when the electricity is more expensive.\n\npretty_table(\n    filtered;\n    fit_table_in_display_horizontally = false,\n    fit_table_in_display_vertically   = false,\n    maximum_number_of_rows            = -1,\n    maximum_number_of_columns         = -1,\n)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"library/internals/methods-EMF/#lib-int-met","page":"Methods - Internal","title":"Methods - Internal","text":"","category":"section"},{"location":"library/internals/methods-EMF/#lib-int-met-idx","page":"Methods - Internal","title":"Index","text":"Pages = [\"methods-EMF.md\"]","category":"section"},{"location":"library/internals/methods-EMF/#lib-int-met-check","page":"Methods - Internal","title":"Check methods","text":"","category":"section"},{"location":"library/internals/methods-EMF/#lib-int-links-fun_utils","page":"Methods - Internal","title":"Utility functions","text":"","category":"section"},{"location":"library/internals/methods-EMF/#EnergyModelsFlex.check_period_ts","page":"Methods - Internal","title":"EnergyModelsFlex.check_period_ts","text":"check_period_ts(ts::RepresentativePeriods, n::PeriodDemandSink, msg::String)\ncheck_period_ts(ts::OperationalScenarios, n::PeriodDemandSink, msg::String)\ncheck_period_ts(ts::SimpleTimes, n::PeriodDemandSink, msg::String)\n\nFunction for checking that the timestructure is valid in combination with the chosen period structure in a [PeriodDemandSink(@ref).\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMF/#EnergyModelsFlex.check_limits_default","page":"Methods - Internal","title":"EnergyModelsFlex.check_limits_default","text":"check_limits_default(n::Union{LimitedFlexibleInput, Combustion})\n\nThis function checks that the limits of a LimitedFlexibleInput or Combustion node are valid.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMF/#EnergyModelsFlex.check_input","page":"Methods - Internal","title":"EnergyModelsFlex.check_input","text":"check_input(n::Union{LimitedFlexibleInput, Combustion})\n\nThis function checks that the input of a LimitedFlexibleInput or Combustion node are valid.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMF/#EnergyModelsFlex.avg_cap_price","page":"Methods - Internal","title":"EnergyModelsFlex.avg_cap_price","text":"avg_cap_price(l::CapacityCostLink, t_sub::Vector{TS.TimePeriod})\n\nReturn the average capacity price over the sub period t_sub for the CapacityCostLink l.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMF/#EnergyModelsFlex.create_sub_periods","page":"Methods - Internal","title":"EnergyModelsFlex.create_sub_periods","text":"create_sub_periods(l::CapacityCostLink, ùíØ)\n\nExtract sub periods of the CapacityCostLink l.\n\n\n\n\n\n","category":"function"},{"location":"nodes/sink/loadshiftingnode/#nodes-loadshiftingnode","page":"LoadShiftingNode","title":"LoadShiftingNode","text":"LoadShiftingNode is a specialized Sink node that allows for batch-wise load shifting. It is designed for demand profiles where discrete production batches can be rescheduled within defined working shifts. This flexibility allows modeling of industrial processes that can shift load within operational constraints. LoadShiftingNodes introduce integer and continuous variables to allow demand shifting across time, subject to batching, balance, and capacity constraints.\n\nwarning: Warning\nThis node is designed for uniform timestep durations. Irregular durations may cause misalignment of shifted loads.\n\ndanger: Experimental node\nThe node is experimental and has in its current version a lot of prerequisites:This node is designed for uniform timestep durations. Irregular durations may cause misalignment of shifted loads.\nThe node utilizes the indices of the operational period. It cannot be used with OperationalScenarios and RepresentativePeriods.Its application should be carefully evaluated.","category":"section"},{"location":"nodes/sink/loadshiftingnode/#nodes-loadshiftingnode-fields","page":"LoadShiftingNode","title":"Introduced type and its fields","text":"The LoadShiftingNode extends the basic Sink with load shifting logic based on indexed operational periods and discrete batch shifts.\n\nThe fields of a LoadShiftingNode are:\n\nid:\nIdentifier for the node.\ncap::TimeProfile:\nThe original, unshifted demand profile.\npenalty::Dict{Symbol,<:TimeProfile}:\nPenalties for :surplus and :deficit, though not actively used in the load shifting formulation.\ninput::Dict{<:Resource,<:Real}:\nResource inputs and their conversion factors.\nload_shift_times::Vector{<:Int}:\nIndices of time steps where batches may be shifted from/to.\nload_shifts_per_period::Int:\nMaximum number of batch shifts allowed within each load shifting group.\nload_shift_duration::Int:\nNumber of consecutive periods each load shift lasts.\nload_shift_magnitude::Real:\nThe magnitude of demand shifted per period in a batch.\nload_shift_times_per_period::Int:\nNumber of time steps per shift group in which shifts may occur.\ndata::Vector{Data}:\nOptional metadata (e.g., emissions, investment data).\n\nwarning: Warning\nThis node is designed for uniform timestep durations. Irregular durations may cause misalignment of shifted loads.\n\nwarning: No investments\nInvestments are not implemented for this node.","category":"section"},{"location":"nodes/sink/loadshiftingnode/#nodes-loadshiftingnode-math","page":"LoadShiftingNode","title":"Mathematical description","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as\n\ntextttvar_exampleindex_1 index_2\n\nwith square brackets, while functions are represented as\n\nfunc_example(index_1 index_2)\n\nwith paranthesis.","category":"section"},{"location":"nodes/sink/loadshiftingnode/#nodes-loadshiftingnode-math-var","page":"LoadShiftingNode","title":"Variables","text":"In addition to standard Sink variables:\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttsink_surplus\ntextttsink_deficit\ntextttemissions_node if EmissionsData is added to the field data\n\nthe node introduces:\n\ntextttload_shift_fromn t:\nInteger variable for number of batches shifted away from operational period t. This variable is only defined for the operational periods given by the vector load_shift_times.\ntextttload_shift_ton t:\nInteger variable for number of batches shifted to operational period t. This variable is only defined for the operational periods given by the vector load_shift_times.\ntextttload_shiftedn t:\nContinuous variable representing the net capacity added or removed via load shifting at operational period t.","category":"section"},{"location":"nodes/sink/loadshiftingnode/#nodes-loadshiftingnode-math-con","page":"LoadShiftingNode","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of LoadShiftingNode nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all LoadShiftingNode types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/sink/loadshiftingnode/#nodes-loadshiftingnode-math-con-stand","page":"LoadShiftingNode","title":"Standard constraints","text":"Load shifting nodes nodes utilize in general the standard constraints described on Constraint functions. In fact, they use the same create_node function as a RefSource node. These standard constraints are:\n\nconstraints_flow_in:\ntextttflow_inn t p =\ninputs(n p) times textttcap_usen t\nqquad forall p in inputs(n)\ntip: Multiple inputs\nThe constrained above allows for the utilization of multiple inputs with varying ratios. It is however necessary to deliver the fixed ratio of all inputs.\nconstraints_opex_fixed:\nThe current implementation fixes the fixed operating expenses of a sink to 0.\ntextttopex_fixedn t_inv = 0\nconstraints_opex_var:\nbeginaligned\ntextttopex_varn t_inv =  \n  sum_t in t_inv  surplus_penalty(n t) times textttsink_surplusn t +  \n  deficit_penalty(n t) times textttsink_deficitn t times  \n  scale_op_sp(t_inv t)\nendaligned\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified additional data, see above.\n\nThe function constraints_capacity receives a new method to handle the load shifting constraints:\n\nconstraints_capacity\nGroup-level limits on load shifts:\nFor each group of nload_shift_times_per_period steps:\nsum textttload_shift_fromn textgroup leq nload_shifts_per_period\nsum textttload_shift_ton textgroup leq nload_shifts_per_period\nsum textttload_shift_fromn textgroup =\nsum textttload_shift_ton textgroup\nThis ensures no net addition or removal of demand‚Äîonly rescheduling.\nDefine shifted load across duration:\nFor each time t in nload_shift_times, and for each period t+i in nload_shift_duration:\ntextttload_shiftedn t+i =\nnload_shift_magnitude times\n(textttload_shift_ton t - textttload_shift_fromn t)\nZero shifted load outside batch duration periods:\ntextttload_shiftedn t = 0\nqquad forall t notin textshifted batch times\nFinal demand with shifted load:\ntextttcap_usen t = textttcap_instn t + textttload_shiftedn t\ntip: Batch interpretation\nEach shift moves a batch of demand of fixed size and duration. Shifted batches cannot be split or partially allocated‚Äîthis preserves discrete process modeling.\nnote: Integer programming\nLoad shifting relies on integer variables (load_shift_from, load_shift_to), making this a mixed-integer problem (MIP).","category":"section"},{"location":"nodes/sink/multipleinputsink/#nodes-mul_in_sink","page":"MultipleInputSink","title":"MultipleInputSink node","text":"MultipleInputSink nodes are Sink nodes that allow the use of multiple energy carriers (resources) to satisfy a single demand. Each input resource has a conversion factor, and their combined contribution must meet the demand.","category":"section"},{"location":"nodes/sink/multipleinputsink/#nodes-mul_in_sink-fields","page":"MultipleInputSink","title":"Introduced type and its fields","text":"The MultipleInputSink node extends the Sink functionality to support multiple simultaneous energy inputs with equivalent service delivery. This is useful for modeling technologies such as hybrid heating systems or multi-fuel industrial boilers.\n\nThe fields of a MultipleInputSink node are given as:\n\nid:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal demand of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\npenalty::Dict{Symbol,<:TimeProfile}:\nThe penalty dictionary is used for providing penalties for soft constraints to allow for both over and under delivering the demand.\nIt must include the fields :surplus and :deficit. In addition, it is crucial that the sum of both values is larger than 0 to avoid an unconstrained model.\ninput::Dict{<:Resource,<:Real}:\nThe field input includes Resources with their corresponding conversion factors as dictionaries.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used.\nnote: Included constructor\nThe field data is not required as we include a constructor when the value is excluded.\ndanger: Using `CaptureData`\nAs a Sink node does not have any output, it is not possible to utilize CaptureData. If you still plan to specify it, you will receive an error in the model building.","category":"section"},{"location":"nodes/sink/multipleinputsink/#nodes-mul_in_sink-math","page":"MultipleInputSink","title":"Mathematical description","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as\n\ntextttvar_exampleindex_1 index_2\n\nwith square brackets, while functions are represented as\n\nfunc_example(index_1 index_2)\n\nwith paranthesis.","category":"section"},{"location":"nodes/sink/multipleinputsink/#nodes-mul_in_sink-math-var","page":"MultipleInputSink","title":"Variables","text":"","category":"section"},{"location":"nodes/sink/multipleinputsink/#nodes-mul_in_sink-math-var-stand","page":"MultipleInputSink","title":"Standard variables","text":"The MultipleInputSink nodes utilize all standard variables from a Sink node, as described on the page Optimization variables. The variables include:\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttsink_surplus\ntextttsink_deficit\ntextttemissions_node if EmissionsData is added to the field data\n\nIt does not add any additional variables.","category":"section"},{"location":"nodes/sink/multipleinputsink/#nodes-mul_in_sink-math-con","page":"MultipleInputSink","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of MultipleInputSink nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all MultipleInputSink types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/sink/multipleinputsink/#nodes-mul_in_sink-math-con-stand","page":"MultipleInputSink","title":"Standard constraints","text":"MultipleInputSink utilize in general the standard constraints that are implemented for a Sink node as described in the documentation of EnergyModelsBase. These standard constraints are:\n\nconstraints_capacity:\ntextttcap_usen t + textttsink_deficitn t = textttcap_instn t + textttsink_surplusn t\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_opex_fixed:\nThe current implementation fixes the fixed operating expenses of a sink to 0.\ntextttopex_fixedn t_inv = 0\nconstraints_opex_var:\nbeginaligned\ntextttopex_varn t_inv =  \n  sum_t in t_inv  surplus_penalty(n t) times textttsink_surplusn t +  \n  deficit_penalty(n t) times textttsink_deficitn t times  \n  scale_op_sp(t_inv t)\nendaligned\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified additional data, see above.\n\nThe function constraints_flow_in receives a new method to account for that the individual resources can be used interchangeably adjusted by their specific conversion factor:\n\nsum_p in P fractextttinflowntpinputs(np)=textttcap_usent\n\nThe total effective input from all resources (accounting for their conversion factors) must equal the capacity used to meet demand.\n\ntip: Conversion factors\nThe input resource values in textttflow_in are divided by their conversion factors to normalize their contribution toward demand fulfillment.","category":"section"},{"location":"examples/capacity_cost_link/#examples-capacity_cost_link","page":"Capacity cost link","title":"Capacity cost link","text":"This example illustrates the usage of CapacityCostLink from EnergyModelsFlex. The example consists of a cheap source, an expensive source, and a sink. Two links connect these nodes: a Direct link from the expensive source and a CapacityCostLink from the cheap source. The model compares the operational costs and capacity utilization of these two routing options across three strategic periods with varying capacity costs. There is a peak demand in the first two operational periods (at 10 and 9 MW) that must be covered followed by low demand (1 MW) for the remaining operational periods. Two sub periods are defined for the CapacityCostLink, allowing it to optimize its capacity usage based on the varying capacity costs over the year.\n\nStart by importing the required packages\n\nusing TimeStruct\nusing EnergyModelsBase\nusing EnergyModelsFlex\n\nusing HiGHS\nusing JuMP\nusing PrettyTables\n\nconst EMF = EnergyModelsFlex\n\nDefine the different resources\n\npower = ResourceCarrier(\"Power\", 0.0)\nco2 = ResourceEmit(\"CO‚ÇÇ\", 0.0)\nùí´ = [power, co2]\n\nCreation of the time structure and global data\n\nop_number = 24\nùíØ = TwoLevel([1, 2, 10], SimpleTimes(op_number, 1); op_per_strat = 8760)\nmodeltype = OperationalModel(\n    Dict(co2 => FixedProfile(10)),\n    Dict(co2 => FixedProfile(0)),\n    co2,\n)\n\nCreate the nodes\n\nsrc_cheap = RefSource(\n    \"cheap source\",\n    FixedProfile(10),\n    FixedProfile(100),\n    FixedProfile(0),\n    Dict(power => 1),\n)\nsrc_exp = RefSource(\n    \"expensive source\",\n    FixedProfile(10),\n    FixedProfile(400),\n    FixedProfile(0),\n    Dict(power => 1),\n)\nsink = RefSink(\n    \"sink\",\n    OperationalProfile([10, 9, fill(1, op_number-2)...]),\n    Dict(:surplus => FixedProfile(4), :deficit => FixedProfile(1e4)),\n    Dict(power => 1),\n)\n\nCollect the nodes\n\nùí© = [src_cheap, src_exp, sink]\n\nConnect the nodes\n\nl_direct = Direct(\"Direct link\", src_exp, sink, Linear())\nl_capacity = CapacityCostLink(\n    \"Capacity cost link\",\n    src_cheap,                          # from\n    sink,                               # to\n    FixedProfile(10),                   # capacity\n    StrategicProfile([5e5, 1e6, 2e6]),  # capacity price\n    2,                                  # capacity price period\n    power,                              # capacity constrained resource\n)\n‚Ñí = [l_direct, l_capacity]\n\nInput data structure and modeltype creation\n\ncase = Case(ùíØ, ùí´, [ùí©, ‚Ñí])\n\nCreate and optimize the model\n\noptimizer = optimizer_with_attributes(HiGHS.Optimizer, MOI.Silent() => true)\nm = create_model(case, modeltype)\nset_optimizer(m, optimizer)\noptimize!(m)\n\nExtract data\n\ndemand = value.(m[:cap_use][sink, :])\ndirect_flow = [value(m[:link_in][l_direct, t, power]) for t ‚àà ùíØ]\ncapacitycostlink_flow = [value(m[:link_in][l_capacity, t, power]) for t ‚àà ùíØ]\nperiods = collect(ùíØ)\n\nopex_var_cheap = value.(m[:opex_var][src_cheap, :])\nopex_var_expensive = value.(m[:opex_var][src_exp, :])\nlink_opex_var = value.(m[:link_opex_var][l_capacity, :])\n\nùíØ‚Å±‚Åø·µõ = collect(strategic_periods(ùíØ))\ncap_price = [EMF.cap_price(l_capacity)[t] for t ‚àà ùíØ‚Å±‚Åø·µõ]","category":"section"},{"location":"examples/capacity_cost_link/#Display-link-usage","page":"Capacity cost link","title":"Display link usage","text":"From the table below we see that the Direct link is used more when the CapacityCostLink has a high capacity price, e.g., in strategic periods\n\nIn contrast, when the capacity price is low, e.g., in periods\n\n1 and 2, the CapacityCostLink is used, but not more than 1 MW as any higher amount would result in higher max_cap_use_sub_period cost just to be able to cover the two first operational periods\n\npretty_table(\n    hcat(periods, demand, direct_flow, capacitycostlink_flow);\n    column_labels                     = [\n    [\"Period\", \"Demand\", \"Flow\", \"Flow\"],\n    [\"\", \"Sink\", \"Direct\", \"CapacityCostLink\"]],\n    fit_table_in_display_horizontally = false,\n    fit_table_in_display_vertically   = false,\n    maximum_number_of_rows            = -1,\n    maximum_number_of_columns         = -1,\n)","category":"section"},{"location":"examples/capacity_cost_link/#Display-operational-expenditures","page":"Capacity cost link","title":"Display operational expenditures","text":"From the table below we see that the CapacityCostLink is used (has OPEX) only when the capacity price is sufficiently low (strategic periods 1 and 2). When the capacity price is high (strategic period 3), the CapacityCostLink is not used, and the Direct link (from the expensive source) covers the demand instead.\n\npretty_table(\n    hcat(ùíØ‚Å±‚Åø·µõ, cap_price, link_opex_var, opex_var_cheap, opex_var_expensive);\n    column_labels                     = [\n    [\"Period\", \"Capacity Price\", \"OPEX (link)\", \"OPEX (cheap node)\", \"OPEX (expensive node)\"],\n    [\"\", \"CapacityCostLink\", \"CapacityCostLink\", \"RefSource\", \"RefSource\"]],\n    formatters                        = [fmt__printf(\"%5.3g\")],\n    fit_table_in_display_horizontally = false,\n    fit_table_in_display_vertically   = false,\n    maximum_number_of_rows            = -1,\n    maximum_number_of_columns         = -1,\n)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"nodes/source/inflexiblesource/#nodes-inflexiblesource","page":"InflexibleSource","title":"Inflexible source node","text":"Inflexible sources represent energy sources with fixed capacity usage that cannot be varied operationally. Unlike flexible sources (e.g., like RefSource) that can adjust output based on system needs, inflexible sources operate at their full installed capacity in every operational period. Examples include must-run generation units, baseload power plants with operational constraints, or heat that must be either cooled down or utilized.\n\nThe InflexibleSource is implemented as a simplified variant of the RefSource that enforces constant capacity utilization.","category":"section"},{"location":"nodes/source/inflexiblesource/#nodes-inflexiblesource-fields","page":"InflexibleSource","title":"Introduced type and its fields","text":"The InflexibleSource extends the Source type with fixed operational characteristics.","category":"section"},{"location":"nodes/source/inflexiblesource/#nodes-inflexiblesource-fields-stand","page":"InflexibleSource","title":"Standard fields","text":"The InflexibleSource has the same standard fields as the RefSource:\n\nid:\nThe field id is only used for providing a name to the node. This is similar to the approach utilized in EnergyModelsBase.\ncap::TimeProfile:\nThe installed capacity corresponds to the forced capacity usage of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of a strategic period as outlined on Utilize TimeStruct.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\noutput::Dict{<:Resource, <:Real}:\nThe field output includes Resources with their corresponding conversion factors as dictionaries. In the case of a non-dispatchable renewable energy source, output should always include your electricity resource. In practice, you should use a value of 1.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is only relevant for additional investment data when EnergyModelsInvestments is used.\nnote: Note\nThe field data is not required as we include a constructor when the value is excluded.\nwarning: Using `CaptureData`\nIf you plan to use CaptureData for a InflexibleSource node, it is crucial that you specify your CO‚ÇÇ resource in the output dictionary. The chosen value is however not important as the CO‚ÇÇ flow is automatically calculated based on the process utilization and the provided process emission value. The reason for this necessity is that flow variables are declared through the keys of the output dictionary. Hence, not specifying CO‚ÇÇ as output resource results in not creating the corresponding flow variable and subsequent problems in the design.We plan to remove this necessity in the future. As it would most likely correspond to breaking changes, we have to be careful to avoid requiring major changes in other packages.","category":"section"},{"location":"nodes/source/inflexiblesource/#nodes-inflexiblesource-math","page":"InflexibleSource","title":"Mathematical description","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as\n\ntextttvar_exampleindex_1 index_2\n\nwith square brackets, while functions are represented as\n\nfunc_example(index_1 index_2)\n\nwith paranthesis.","category":"section"},{"location":"nodes/source/inflexiblesource/#nodes-inflexiblesource-math-var","page":"InflexibleSource","title":"Variables","text":"","category":"section"},{"location":"nodes/source/inflexiblesource/#nodes-inflexiblesource-math-var-stand","page":"InflexibleSource","title":"Standard variables","text":"The inflexible source node type utilize all standard variables from the RefSource node type, as described on the page Optimization variables. The variables include:\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data.","category":"section"},{"location":"nodes/source/inflexiblesource/#nodes-inflexiblesource-math-con","page":"InflexibleSource","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of inflexible source nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N^textinflexiblesource_source for all InflexibleSource types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all strategic periods).","category":"section"},{"location":"nodes/source/inflexiblesource/#nodes-inflexiblesource-math-con-stand","page":"InflexibleSource","title":"Standard constraints","text":"Inflexible source nodes utilize in general the standard constraints described on Constraint functions. In fact, they use the same create_node function as a RefSource node. These standard constraints are:\n\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_out:\ntextttflow_outn t p =\noutputs(n p) times textttcap_usen t\nqquad forall p in outputs(n) setminus textCO_2\nconstraints_opex_fixed:\ntextttopex_fixedn t_inv = opex_fixed(n t_inv) times textttcap_instn first(t_inv)\ntip: Why do we use `first()`\nThe variables textttcap_inst are declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacities in the first operational period of a given strategic period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\ntextttopex_varn t_inv = sum_t in t_inv opex_var(n t) times textttcap_usen t times scale_op_sp(t_inv t)\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and strategic periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data: This function is only called for specified additional data, see above.\n\nThe function constraints_capacity is extended with a new method for inflexible source nodes to allow the fixing of the textttcap_usen t to the variable textttcap_instn t (only replacing inequality with equality compared to RefSource). It now includes the individual constraint:\n\ntextttcap_usen t = textttcap_instn t\n\nThis function still calls the subfunction constraints_capacity_installed to limit the variable textttcap_instn t or provide capacity investment options.","category":"section"},{"location":"nodes/source/inflexiblesource/#nodes-inflexiblesource-math-con-add","page":"InflexibleSource","title":"Additional constraints","text":"InflexibleSource nodes do not add additional constraints.","category":"section"},{"location":"manual/quick-start/#man-quick_start","page":"Quick Start","title":"Quick Start","text":"Install the most recent version of Julia\nInstall the package EnergyModelsBase and the time package TimeStruct, by running:\n] add TimeStruct\n] add EnergyModelsBase\nThese packages are required as we do not only use them internally, but also for building a model.\nInstall the package EnergyModelsFlex\n] add EnergyModelsFlex\n\nnote: Registration\n\n\nIf you receive an error that the pacakge is not yet registered, you must clone the package from GitHub directly.\n\nYou also have to install a solver for solving the optimization problem. Depending on the type of node you plan to utilize, you can either use a standard solver or a solver supporting MOI.ScalarQuadraticFunction{Float64} in MOI.EqualTo{Float64}. In either case, you have to\n\nInstall JuMP by running:\n] add JuMP\nInstall your chosen solver, e.g., SCIP and Gurobi, by running:\n] add SCIP\n] add Gurobi\n\nYou may, depending on your operating system, also have to locally install the solver in addition as explained in the corresponding README file.\n\ntip: JuMP and solver\nWhile JuMP is automatically installed when you add EnergyModelsBase, it is still necessary to load it to optimize a model or extract the results. It is hence necessary to load it in each model run explicitly.EnergyModelsX models are in general agnostic towards which solver is used. They are hence not automatically included. Therefore, they require you to explicitly load the corresponding solver.","category":"section"},{"location":"library/internals/methods-EMB/#lib-int-met_emb","page":"Methods - EMB","title":"Methods - EMB","text":"","category":"section"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-idx","page":"Methods - EMB","title":"Index","text":"Pages = [\"methods-EMB.md\"]","category":"section"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-ext","page":"Methods - EMB","title":"Extension methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-con","page":"Methods - EMB","title":"Constraint methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-check","page":"Methods - EMB","title":"Check methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-field","page":"Methods - EMB","title":"Field extraction methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.variables_element","page":"Methods - EMB","title":"EnergyModelsBase.variables_element","text":"EMB.variables_element(m, ùí©À¢‚Å±‚Åø·µè::Vector{<:AbstractPeriodDemandSink}, ùíØ, ::EnergyModel)\n\nCreates the following additional variables for ALL PeriodDemandSink nodes:\n\ndemand_sink_surplus[n, i] is a non-negative variable indicating a surplus in demand in each period i.\ndemand_sink_deficit[n, i] is a non-negative variable indicating a deficit in demand for each period i.\n\nnote: Definition of period\nThe period in the description above does not correspond to an operational period as known from TimeStruct. Instead, it is a period in which the demand must be satisfied. A period can consist of multiple operational periods.\n\n\n\n\n\nEMB.variables_element(m, ùí©::Vector{<:AbstractMultipleInputSinkStrat}, ùíØ, ::EnergyModel)\n\nCreates the following additional variables for ALL AbstractMultipleInputSinkStrat subtypes:\n\ninput_frac_strat[n, t_inv, p] is the fraction of the demand satisfied by resource p in investment period t_inv.\nsink_surplus_p[n, t, p] is the surplus of resource p in operational period t.\nsink_deficit_p[n, t, p] is the deficit of resource p in operational period t.\n\n\n\n\n\nEMB.variables_element(m, ùí©::Vector{BinaryMultipleInputSinkStrat}, ùíØ, ::EnergyModel)\n\nModifies the variable input_frac_strat[n, t_inv, p] of BinaryMultipleInputSinkStrat to be binary to not allow fuel switching within a strategic period.\n\n\n\n\n\nEMB.variables_element(m, ùí©·¥∏À¢::Vector{<:LoadShiftingNode}, ùíØ, ::EnergyModel)\n\nCreates the following additional variables for ALL LoadShiftingNode nodes.\n\nload_shift_from[n, t] is an integer variable for how many batches are shifted away from time period t.\nload_shift_to[n, t] is an integer variable for how many batches are shifted to the time period t.\n:load_shifted[n ,t] is a continous variable for the total capacity load shifted in time period t. The variable can also be negative indicating a load shifted from this time period.\n\nThe individual time periods which allow for load shifting are declared by the parameter load_shift_times.\n\n\n\n\n\nEMB.variables_element(m, ùí©uc::Vector{UnitCommitmentNode}, ùíØ, ::EnergyModel)\n\nArguments\n\nm: The optimization model.\nùí©uc: A vector of unit commitment nodes.\nùíØ: The time structure.\nmodeltype: The type of energy model.\n\nVariables\n\nonswitch[n, t]: Binary variable indicating the node is switched on.\noffswitch[n, t]: Binary variable indicating the node is switched off.\non_off[n, t]: Binary variable indicating the node's on/off state.\n\n\n\n\n\nEMB.variables_element(m, ‚ÑíÀ¢·µò·µá::Vector{<:CapacityCostLink}, ùíØ, modeltype::EnergyModel)\n\nCreates the following additional variable for ALL capacity cost links:\n\nccl_max_cap_use[l, t] is a continuous variable describing the maximum capacity usage over sub periods for a CapacityCostLink l in operational period t.\nccl_cap_cost[l, t] is a continuous variable describing the cost over sub periods for a CapacityCostLink l in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.create_link","page":"Methods - EMB","title":"EnergyModelsBase.create_link","text":"EMB.create_link(m, l::CapacityCostLink, ùíØ, ùí´, modeltype::EnergyModel)\n\nWhen the link is a CapacityCostLink, the constraints for a link include capacity-based cost constraints.\n\nIn addition, a CapacityCostLink includes a capacity with the potential for investments.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.has_capacity","page":"Methods - EMB","title":"EnergyModelsBase.has_capacity","text":"EMB.has_capacity(l::CapacityCostLink)\n\nThe CapacityCostLink has a capacity, and hence, requires the declaration of capacity variables.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.has_opex","page":"Methods - EMB","title":"EnergyModelsBase.has_opex","text":"EMB.has_opex(l::CapacityCostLink)\n\nA CapacityCostLink l has operational expenses.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_capacity","page":"Methods - EMB","title":"EnergyModelsBase.constraints_capacity","text":"constraints_capacity(m, n::InflexibleSource, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nFunction for fixing the capacity of a InflexibleSource to the installed capacity.\n\n\n\n\n\nEMB.constraints_capacity(m, n::AbstractPeriodDemandSink, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the maximum capacity utilization of an AbstractPeriodDemandSink.\n\nThe method is changed from the standard approach through calculating the demand period surplus or deficit in addition to the operational period surplus or deficit.\n\n\n\n\n\nEMB.constraints_capacity(m, n::AbstractMultipleInputSinkStrat, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the capacity of a AbstractMultipleInputSinkStrat.\n\nIt differs from the standard method as it does not include the capacity constraint as this is included in constraints_flow_in. Instead, it only calls the subfunction constraints_capacity_installed.\n\n\n\n\n\nEMB.constraints_capacity(m, n::LoadShiftingNode, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nAdd capacity constraints to the optimization model m for a node n representing a load-shifting node over the time structure ùíØ. The constraints ensure that the node's capacity usage respects its operational limits and accounts for load shifting.\n\nArguments\n\nm: The optimization model.\nn: The node representing a load-shifting node.\nùíØ: The time structure.\nmodeltype: The type of energy model.\n\nConstraints\n\nEnsures capacity usage matches installed capacity plus any shifted load.\nLimits the number of load shifts per period.\nBalances load shifts from and to operational periods.\nSets the load_shifted variable to the actual load shifted during load-shifting periods.\nFixes load_shifted to zero for non-load-shifting periods.\n\n\n\n\n\nconstraints_capacity(m, n::MinUpDownTimeNode, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nAdd capacity constraints to the optimization model m for a node n with minimum up/down time requirements over the time structure ùíØ. The constraints ensure that the node's capacity usage respects its operational limits and switching constraints.\n\nArguments\n\nm: The optimization model.\nn: The node with minimum up/down time requirements.\nùíØ: The time structure.\nmodeltype: The type of energy model.\n\nConstraints\n\nEnsures minimum up/down time requirements are met.\nEnforces capacity usage within specified limits.\nAdds switching constraints to prevent simultaneous on/off switching.\n\n\n\n\n\nconstraints_capacity(m, n::ActivationCostNode, ùíØ::TimeStructure, ::EnergyModel)\n\nAdd capacity constraints to the optimization model m for a node n with activation cost considerations over the time structure ùíØ. The constraints ensure that the node's capacity usage respects its operational limits and switching constraints.\n\nConstraints\n\nEnsures proper on/off switching behavior.\nEnforces capacity usage within specified limits.\nAdds constraints to prevent simultaneous on/off switching.\n\nArguments\n\nm: The optimization model.\nn: The node with activation cost considerations.\nùíØ: The time structure.\nmodeltype: The type of energy model.\n\n\n\n\n\nconstraints_capacity(m, n::ElectricBattery, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nAdd capacity constraints to the optimization model m for a node n representing an electric battery over the time structure ùíØ. The constraints ensure that the node's capacity usage respects its operational limits, including charging and discharging rates.\n\nArguments\n\nm: The optimization model.\nn: The node representing an electric battery.\nùíØ: The time structure.\nmodeltype: The type of energy model.\n\nConstraints\n\nEnsures storage level does not exceed installed capacity.\nLimits charge and discharge usage to installed capacity.\nEnforces charging and discharging rates based on the battery's c_rate.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_flow_in","page":"Methods - EMB","title":"EnergyModelsBase.constraints_flow_in","text":"EMB.constraints_flow_in(m, n::MultipleInputSink, ùíØ::TimeStructure)\n\nFunction for creating the constraint on the inlet flow of a MultipleInputSink.\n\nThe difference to the standard constraint is that the MultipleInputSink allows for several different resources can be used interchangably and the ratio is not enforced.\n\n\n\n\n\nEMB.constraints_flow_in(m, n::AbstractMultipleInputSinkStrat, ùíØ::TimeStructure)\n\nFunction for creating the constraint on the inlet flow to a AbstractMultipleInputSinkStrat.\n\nThe difference to the standard method is that the AbstractMultipleInputSinkStrat allows for satisfying the demand with multiple resources as specified through the variable input_frac_strat.\n\nAs a consequence, the method includes the constraints for:\n\nthe capacity utilization (replacing constraints_capacity),\nthe bounds on the individual flows into the node based on the variable input_frac_strat,\nthe summation limit of input_frac_strat, and\nthe calculation of the total deficit in the Sink node.\n\n\n\n\n\nconstraints_flow_in(m, n::ActivationCostNode, ùíØ::TimeStructure, ::EnergyModel)\n\nAdd flow input constraints to the optimization model m for a node n with activation cost considerations over the time structure ùíØ. The constraints ensure that the node's input flows respect its capacity usage and activation consumption.\n\nArguments\n\nm: The optimization model.\nn: The node with activation cost considerations.\nùíØ: The time structure.\nmodeltype: The type of energy model.\n\nConstraints\n\nEnsures input flow respects capacity usage.\nAccounts for activation consumption in input flows.\n\n\n\n\n\nconstraints_flow_in(m, n::LimitedFlexibleInput, ùíØ::TimeStructure, ::EnergyModel)\n\nFunction for creating the constraint on the inlet flow to a LimitedFlexibleInput node. The input resources are limited by the limit field in the node n.\n\n\n\n\n\nconstraints_flow_in(m, n::Combustion, ùíØ::TimeStructure, ::EnergyModel)\n\nFunction for creating the constraint on the inlet flow to a Combustion node. The input resources are limited by the limit field in the node n as for the LimitedFlexibleInput node, but additionally, it is balance requirement for the input and output flows controlled by the heat_resource field in the node n. If outputs(n, p_heat) == 1, then there is flow balance.\n\n\n\n\n\nconstraints_flow_in(m, n::ElectricBattery, ùíØ::TimeStructure, ::EnergyModel)\n\nAdd flow input constraints to the optimization model m for a node n representing an electric battery over the time structure ùíØ. The constraints ensure that the node's input flows respect its storage requirements and efficiency.\n\nArguments\n\nm: The optimization model.\nn: The node representing an electric battery.\nùíØ: The time structure.\nmodeltype: The type of energy model.\n\nConstraints\n\nEnsures additional required input flows are proportional to storage input.\nAccounts for storage rate usage for charging with efficiency.\n\n\n\n\n\nEMB.constraints_flow_in(m, n::StorageEfficiency, ùíØ::TimeStructure, ::EnergyModel)\n\nFunction for creating the constraint on the inlet flow to a StorageEfficiency.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_flow_out","page":"Methods - EMB","title":"EnergyModelsBase.constraints_flow_out","text":"constraints_flow_out(m, n::Combustion, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the outlet flow from a Combustion node.\n\n\n\n\n\nconstraints_flow_out(m, n::FlexibleOutput, ùíØ::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the outlet flow from a FlexibleOutput.\n\n\n\n\n\nEMB.constraints_flow_out(m, n::StorageEfficiency, ùíØ::TimeStructure, ::EnergyModel)\n\nFunction for creating the constraint on the outlet flow from a StorageEfficiency.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_opex_var","page":"Methods - EMB","title":"EnergyModelsBase.constraints_opex_var","text":"constraints_opex_var(m, n::PayAsProducedPPA, ùíØ·¥µ‚Åø·µõ, ::EnergyModel)\n\nFunction for creating the constraint on the variable OPEX of a PayAsProducedPPA node.\n\n\n\n\n\nEMB.constraints_opex_var(m, n::AbstractPeriodDemandSink, ùíØ·¥µ‚Åø·µõ, ::EnergyModel)\n\nFunction for creating the constraint on the variable OPEX of an AbstractPeriodDemandSink.\n\nThe method is adjusted from the default method through utilizing the period demand surplus and deficit instead of the operational period deficit or surplus.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_level_aux","page":"Methods - EMB","title":"EnergyModelsBase.constraints_level_aux","text":"constraints_level_aux(m, n::ElectricBattery, ùíØ, ùí´, ::EnergyModel)\n\nAdd auxiliary level constraints to the optimization model m for a node n representing an electric battery over the time structure ùíØ and subset ùí´. The constraints ensure that the change in storage level is correctly accounted for in each operational period.\n\nArguments\n\nm: The optimization model.\nn: The node representing an electric battery.\nùíØ: The time structure.\nùí´: The subset of periods.\nmodeltype: The type of energy model.\n\nConstraints\n\nEnsures the change in storage level is equal to the difference between charge and discharge usage.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.check_node","page":"Methods - EMB","title":"EnergyModelsBase.check_node","text":"check_node(n::PeriodDemandSink, ùíØ, ::EnergyModel)\n\nThis method checks that a PeriodDemandSink node is valid.\n\nIt reuses the standard checks of a Sink node through calling the function EMB.check_node_default, but adds additional checks on the data.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe values of the dictionary input are required to be non-negative.\nThe dictionary penalty is required to have the keys :deficit and :surplus.\nThe sum of the values :deficit and :surplus in the dictionary penalty has to be non-negative to avoid an infeasible model.\nThe remainder of the divison of the lowest time structure by the period length must be 0.\nThe length of the period demand must equal the length of the lowest period times the parameter period length.\n\n\n\n\n\nEMB.check_node(n::LoadShiftingNode, ùíØ, ::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that the LoadShiftingNode node is valid.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe values of the dictionary input are required to be positive.\nThe values of loadshifttimes are required to be larger than 0.\nThe values of loadshifttimes are required to be less than the length of ùíØ.\nThe values of loadshiftmagnitude are required to be non-negative.\nThe values of loadshiftduration are required to be positive.\nThe values of loadshiftsper_period are required to be non-negative.\n\n\n\n\n\nEMB.check_node(n::MinUpDownTimeNode, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that a MinUpDownTimeNode node is valid.\n\nChecks\n\nThe minimum capacity must be greater than zero.\nThe minimum capacity must not be larger than maximum capacity.\n\n\n\n\n\nEMB.check_node(\n    n::LimitedFlexibleInput,\n    ùíØ,\n    modeltype::EnergyModel,\n    check_timeprofiles::Bool,\n)\n\nThis method checks that a LimitedFlexibleInput node is valid.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe values of the dictionary input are required to be positive.\nThe values of the dictionary output are required to be non-negative.\nThe value of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function check_fixed_opex(n, ùíØ·¥µ‚Åø·µõ, check_timeprofiles).\nThe values of the dictionary limit are required to be non-negative.\nThe values of the dictionary limit are required to not be larger than 1.\n\n\n\n\n\nEMB.check_node(n::Combustion, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that a Combustion node is valid.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe values of the dictionary input are required to be positive.\nThe values of the dictionary output are required to be non-negative.\nThe value of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function check_fixed_opex(n, ùíØ·¥µ‚Åø·µõ, check_timeprofiles).\nThe values of the dictionary limit are required to be non-negative.\nThe values of the dictionary limit are required to not be larger than 1.\nThe resource in the heat_res field must be in the dictionary output.\n\n\n\n\n\nEMB.check_node(n::FlexibleOutput, ùíØ, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that a FlexibleOutput node is valid.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe values of the dictionary input are required to be non-negative.\nThe values of the dictionary output are required to be positive.\nThe value of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function check_fixed_opex(n, ùíØ·¥µ‚Åø·µõ, check_timeprofiles).\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.check_link","page":"Methods - EMB","title":"EnergyModelsBase.check_link","text":"EMB.check_link(l::CapacityCostLink, ùíØ,  ::EnergyModel, ::Bool)\n\nThis method checks that the CapacityCostLink link is valid.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe field cap_price is required to be non-negative.\nThe field cap_price_period is required to be positive.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.capacity","page":"Methods - EMB","title":"EnergyModelsBase.capacity","text":"EMB.capacity(l::CapacityCostLink)\nEMB.capacity(l::CapacityCostLink, t)\n\nReturns the capacity of a capacity cost link l as TimeProfile or in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.inputs","page":"Methods - EMB","title":"EnergyModelsBase.inputs","text":"EMB.inputs(l::CapacityCostLink)\n\nReturns the input resources of a capacity cost link l, corresponding to its cap_resource.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.outputs","page":"Methods - EMB","title":"EnergyModelsBase.outputs","text":"EMB.outputs(l::CapacityCostLink)\n\nReturns the output resources of a capacity cost link l, corresponding to its cap_resource.\n\n\n\n\n\n","category":"function"},{"location":"nodes/sink/multipleinputsinkstrat/#nodes-mul_in_sink_strat","page":"AbstractMultipleInputSinkStrat","title":"AbstractMultipleInputSinkStrat node","text":"AbstractMultipleInputSinkStrat are Sink nodes that models flexible energy service demands that can be met by a combination of multiple input resources. Unlike MultipleInputSink nodes, we enforce that the ratio between the different input resources is the same in all operational periods of an investment period. The AbstractMultipleInputSinkStrat introduces strategic-period-based input fractions, used to proportionally allocate resource inflows across each operational period. This allows for continuous blending of energy carriers in a flexible and cost-optimal way.\n\nwarning: InvestmentData\nThe current implementation does not allow for the incorporation of investment data as this would lead to bilinear constraints.","category":"section"},{"location":"nodes/sink/multipleinputsinkstrat/#nodes-mul_in_sink_strat-fields","page":"AbstractMultipleInputSinkStrat","title":"Introduced types and their fields","text":"We implement two types of AbstractMultipleInputSinkStrat nodes:\n\nContinuousMultipleInputSinkStrat and\nBinaryMultipleInputSinkStrat.\n\nContinuousMultipleInputSinkStrat allows for a continuous blend between the different input resources while BinaryMultipleInputSinkStrat requires that either one or the other resource is utilized.\n\ntip: Use cases\nContinuousMultipleInputSinkStrat: Use this node for fuel-flexible technologies where optimal blending between input sources (e.g., electricity and biomass) is required over longer-term strategic decisions.BinaryMultipleInputSinkStrat: This node is ideal for modeling strategic switching between fuels where only one option can be used at a time (e.g., policy-driven exclusivity, binary retrofitting, or fuel-type switching).\n\nwarning: Binary enforcement\nIf you use BinaryMultipleInputSinkStrat, you introduce binary decision variables, making it a mixed-integer optimization problem. Be aware of the increased computational complexity.\n\nBoth nodes have the same fields. These fields are:\n\nid:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal demand of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\npenalty::Dict{Symbol,<:TimeProfile}:\nThe penalty dictionary is used for providing penalties for soft constraints to allow for both over and under delivering the demand.\nIt must include the fields :surplus and :deficit. In addition, it is crucial that the sum of both values is larger than 0 to avoid an unconstrained model.\ninput::Dict{<:Resource,<:Real}:\nThe field input includes Resources with their corresponding conversion factors as dictionaries.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used.\nnote: Included constructor\nThe field data is not required as we include a constructor when the value is excluded.\ndanger: Using `CaptureData`\nAs a Sink node does not have any output, it is not possible to utilize CaptureData. If you still plan to specify it, you will receive an error in the model building.\n\nnote: Note\nThis node supports process emissions if emission data is included in the data field.","category":"section"},{"location":"nodes/sink/multipleinputsinkstrat/#nodes-mul_in_sink_strat-math","page":"AbstractMultipleInputSinkStrat","title":"Mathematical description","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as\n\ntextttvar_exampleindex_1 index_2\n\nwith square brackets, while functions are represented as\n\nfunc_example(index_1 index_2)\n\nwith paranthesis.","category":"section"},{"location":"nodes/sink/multipleinputsinkstrat/#nodes-mul_in_sink_strat-math-var","page":"AbstractMultipleInputSinkStrat","title":"Variables","text":"","category":"section"},{"location":"nodes/sink/multipleinputsinkstrat/#nodes-mul_in_sink_strat-math-var-stand","page":"AbstractMultipleInputSinkStrat","title":"Standard variables","text":"The AbstractMultipleInputSinkStrat nodes utilize all standard variables from a Sink node, as described on the page Optimization variables. The variables include:\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttsink_surplus\ntextttsink_deficit\ntextttemissions_node if EmissionsData is added to the field data\n\nIt does not add any additional variables.","category":"section"},{"location":"nodes/sink/multipleinputsinkstrat/#nodes-mul_in_sink_strat-math-add","page":"AbstractMultipleInputSinkStrat","title":"Additional variables","text":"AbstractMultipleInputSinkStrat nodes declare in addition several variables through dispatching on the method EnergyModelsBase.variables_element() for including constraints for deficits and surplus for individual resources as well as what the fraction satisfied by each resource. These variables are for an AbstractMultipleInputSinkStrat node n in operational period t:\n\ntextttinput_frac_stratn t_inv p:\nFraction of the demand satisfied by input resource p in strategic period t_inv. The fraction is limited between 0 and 1 in the case of ContinuousMultipleInputSinkStrat and is binary in the case of BinaryMultipleInputSinkStrat.\ntextttsink_surplus_pn t p:\nSurplus of input resource p in node n in operational period t.\ntextttsink_deficit_pn t p:\nDeficit of input resource p in node n in operational period t.","category":"section"},{"location":"nodes/sink/multipleinputsinkstrat/#nodes-mul_in_sink_strat-math-con","page":"AbstractMultipleInputSinkStrat","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of AbstractMultipleInputSinkStrat nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all AbstractMultipleInputSinkStrat types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/sink/multipleinputsinkstrat/#nodes-mul_in_sink_strat-math-con-stand","page":"AbstractMultipleInputSinkStrat","title":"Standard constraints","text":"AbstractMultipleInputSinkStrat utilize in general the standard constraints that are implemented for a Sink node as described in the documentation of EnergyModelsBase. These standard constraints are:\n\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\nconstraints_opex_fixed:\nThe current implementation fixes the fixed operating expenses of a sink to 0.\ntextttopex_fixedn t_inv = 0\nconstraints_opex_var:\nbeginaligned\ntextttopex_varn t_inv =  \n  sum_t in t_inv  surplus_penalty(n t) times textttsink_surplusn t +  \n  deficit_penalty(n t) times textttsink_deficitn t times  \n  scale_op_sp(t_inv t)\nendaligned\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified additional data, see above.\n\nThe function constraints_capacity is extended with a new method as we moved the capacity constraint to the function constraints_flow_in as outlined below. As a consequence, it only calls the function constraints_capacity_installed.\n\nThe function constraints_flow_in is extended with a new method to account for the potential of supplying the demand with multiple resources. The inlet overall flow balance is given by\n\nsum_p in P^in fractextttflow_inn t pinputs(n p) =\ntextttcap_usen t\n\nThe inlet flow is linked to the binary choice and the capacity through the following function:\n\nbeginaligned\nfractextttflow_inn t pinputs(n p) +  textttsink_deficit_pn t p = \n capacity(n t_inv) times textttinput_frac_stratn t_inv p + textttsink_surplus_pn t p\nendaligned\n\nThe variable textttinput_frac_strat must sum up to one to avoid problems with the overall mass balance.\n\nsum_p in P^in textttinput_frac_stratn t_inv p = 1\n\nThe sum of the individual surplus and deficits of each resource represent then subsequently the complete surplus and deficit.\n\nbeginaligned\nsum_p in P^in textttsink_surplus_pn t p =  textttsink_surplusn t \nsum_p in P^in textttsink_deficit_pn t p =  textttsink_deficitn t \nendaligned","category":"section"},{"location":"nodes/storage/storageefficiency/#nodes-stor_eff","page":"StorageEfficiency","title":"Storage efficiency node","text":"The reference storage node, RefStorage, does not include any efficiencies for the stored Resource. It is always assumed that there is no associated loss of the stored Resource when charging or discharging the storage. StorageEfficiency nodes are introduced to enable storage efficiency control compared to Storage.\n\nThe nodes utilize the parametric implementation for all storage nodes and the individual capacities for charge and storage level.","category":"section"},{"location":"nodes/storage/storageefficiency/#nodes-stor_eff-fields","page":"StorageEfficiency","title":"Introduced type and its fields","text":"The StorageEfficiency{T} is implemented as a subtype of EMB.Storage{T}, extending the existing Storage node.\n\nThe fields of a StorageEfficiency are:\n\nid:\nThe field id is only used for providing a name to the node.\ncharge::EMB.UnionCapacity:\nThe charging parameters of the Storage node must include a capacity. Depending on the chosen type, the charge parameters can also include variable OPEX and/or fixed OPEX.\nlevel::EMB.UnionCapacity:\nThe level parameters of the Storage node must include a capacity.. Depending on the chosen type, the charge parameters can also include variable OPEX and/or fixed OPEX.\nnote: Permitted values for storage parameters in `charge` and `level`\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. Similarly, you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. The variable operating expenses can be provided as OperationalProfile as well. In addition, all capacity and fixed OPEX values have to be non-negative.\nstor_res::ResourceEmit:\nThe stor_res is the stored Resource.\ninput::Dict{<:Resource,<:Real} and output::Dict{<:Resource,<:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries. The stored Resource (outlined above) must be included to create the linking variables.\ndata::Vector{<:Data}:\nAn entry for providing additional data to the model. In the current version, it is used for additional investment data when EnergyModelsInvestments is used.\nnote: Constructor for `StorageEfficiency`\nThe field data is not required as we include a constructor when the value is excluded.","category":"section"},{"location":"nodes/storage/storageefficiency/#nodes-stor_eff-math","page":"StorageEfficiency","title":"Mathematical description","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as\n\ntextttvar_exampleindex_1 index_2\n\nwith square brackets, while functions are represented as\n\nfunc_example(index_1 index_2)\n\nwith paranthesis.","category":"section"},{"location":"nodes/storage/storageefficiency/#nodes-stor_eff-math-var","page":"StorageEfficiency","title":"Variables","text":"","category":"section"},{"location":"nodes/storage/storageefficiency/#nodes-stor_eff-math-var-stand","page":"StorageEfficiency","title":"Standard variables","text":"The storage efficiency node types utilize all standard variables from the RefStorage{T} node type, as described on the page Optimization variables. The variables include:\n\ntextttopex_var\ntextttopex_fixed\ntextttstor_level_inst\ntextttstor_level\ntextttstor_charge_inst\ntextttstor_charge_use\ntextttflow_in\ntextttflow_out\ntextttstor_level_Œî_op\ntextttstor_level_Œî_rp if the TimeStruct includes RepresentativePeriods\n\nIt does not add any additional variables.","category":"section"},{"location":"nodes/storage/storageefficiency/#nodes-stor_eff-math-con","page":"StorageEfficiency","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of StorageEfficiency nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all StorageEfficiency types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/storage/storageefficiency/#nodes-stor_eff-math-con-stand","page":"StorageEfficiency","title":"Standard constraints","text":"StorageEfficiency utilize in general the standard constraints that are implemented for a Storage node as described in the documentation of EnergyModelsBase. These standard constraints are:\n\nconstraints_capacity:\nbeginaligned\ntextttstor_level_usen t  leq textttstor_level_instn t \ntextttstor_charge_usen t  leq textttstor_charge_instn t\nendaligned\nconstraints_capacity_installed:\nbeginaligned\ntextttstor_level_instn t  = capacity(level(n) t) \ntextttstor_charge_instn t  = capacity(charge(n) t)\nendaligned\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_level:\nThe level constraints are more complex compared to the standard constraints. They are explained in detail below in the description on level constraints in EnergyModelsBase.\nconstraints_opex_fixed:\nbeginaligned\ntextttopex_fixedn t_inv =  \n  opex_fixed(level(n) t_inv) times textttstor_level_instn first(t_inv) +  \n  opex_fixed(charge(n) t_inv) times textttstor_charge_instn first(t_inv)\nendaligned\ntip: Why do we use `first()`\nThe variables textttstor_level_inst are declared over all operational periods (see the section on capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacities in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\nbeginaligned\ntextttopex_varn t_inv =  sum_t in t_inv\n  opex_var(level(n) t) times textttstor_leveln t times scale_op_sp(t_inv t) +  \n  opex_var(charge(n) t) times textttstor_charge_usen t times scale_op_sp(t_inv t)\nendaligned\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified data of the storage node, see above.\n\ninfo: Implementation of OPEX\nEven if a Storage node includes the corresponding capacity field (i.e., charge, level, and discharge), we only include the fixed and variable OPEX constribution for the different capacities if the corresponding storage parameters have a field opex_fixed and opex_var, respectively. Otherwise, they are omitted.\n\nThe functions constraints_flow_in and constraints_flow_out are extended with new methods that, compared to a RefStorage node, better controls the storage efficiency:\n\nThe function constraints_flow_in is exytended with a new method to incorporate the conversion factor also for the stored resource. The effective charging rate is defined by the conversion factor (typically <1) of the stored resource p_textstor:\n\ntextttstor_charge_usen t = textttflow_inn t p_textstor times inputs(n p_textstor)\n\nFor each additional input resource p  inputs(n) setminus p_textstor, the flow is proportional to the main storage flow by a conversion factor:\n\ntextttflow_inn t p = textttflow_inn tp_textstor times inputs(np)\n\nThe function constraints_flow_out is extended with a new method to incorporate the conversion factor for discharging_\n\ntextttflow_outn tpstor=textttstor_discharge_usen t times outputs(n p_textstor)\n\nThis models energy losses when discharging from storage (e.g., thermal or round-trip losses in batteries).","category":"section"},{"location":"nodes/network/combustion/#nodes-combustion","page":"Combustion","title":"Combustion node","text":"Combustion nodes are a variant of NetworkNodes that model fuel-based conversion processes where input energy is either transformed into useful outputs or lost as residual heat. The node enforces a complete energy balance, with residual losses explicitly accounted for using a designated heat_res output.\n\ntip: Use cases\nUse this node when modeling combustion or transformation technologies where energy losses are explicit (e.g., boilers, engines, incinerators). It is especially valuable for modeling thermodynamic efficiencies or waste heat utilization.","category":"section"},{"location":"nodes/network/combustion/#nodes-combustion-fields","page":"Combustion","title":"Introduced type and its fields","text":"The Combustion node is similar to LimitedFlexibleInput, but includes an additional energy conservation constraint. It uses a dedicated resource (heat_res) to capture residual or waste heat.","category":"section"},{"location":"nodes/network/combustion/#nodes-combustion-fields-stand","page":"Combustion","title":"Standard fields","text":"The standard fields are given as:\n\nid:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal capacity of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified input and output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of an investment period as outlined on Utilize TimeStruct.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\ninput::Dict{<:Resource,<:Real} and output::Dict{<:Resource,<:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries.\nCO‚ÇÇ cannot be directly specified, i.e., you cannot specify a ratio. If you use CaptureData, it is however necessary to specify CO‚ÇÇ as output, although the ratio is not important.\nAll values have to be non-negative.\ndata::Vector{<:Data}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used.\nnote: Constructor for `Combustion`\nThe field data is not required as we include a constructor when the value is excluded.\nwarning: Using `CaptureData`\nIf you plan to use CaptureData for a Combustion node, it is crucial that you specify your CO‚ÇÇ resource in the output dictionary. The chosen value is however not important as the CO‚ÇÇ flow is automatically calculated based on the process utilization and the provided process emission value. The reason for this necessity is that flow variables are declared through the keys of the output dictionary. Hence, not specifying CO‚ÇÇ as output resource results in not creating the corresponding flow variable and subsequent problems in the design.We plan to remove this necessity in the future. As it would most likely correspond to breaking changes, we have to be careful to avoid requiring major changes in other packages.","category":"section"},{"location":"nodes/network/combustion/#nodes-combustion-fields-new","page":"Combustion","title":"Additional fields","text":"Combustion nodes add two additional fields compared to a NetworkNode:\n\nlimit::Dict{<:Resource,<:Real}:\nA dictionary specifying the maximum share that each input resource may contribute to total inflow. All values should be in the range 0 1. Resources which are specified in the input dictionary, but not in the limit dictionary will be treated as unconstrained. This corresponds to a value of 1 in the limit dictionary.\nheat_res::Resource:\nThe residual heat or loss resource used to close the energy balance. This resource must be in the output dictionary. The residual output defined by heat_res is not necessarily \"useful\" energy ‚Äî it serves to account for efficiency losses or heat rejection in the energy balance.\nwarning: Correct definition of `heat_res`\nIt is essential that the resource defined in heat_res is also included in the output dictionary. If not, the residual balance constraint will not be well-formed and the model may fail.","category":"section"},{"location":"nodes/network/combustion/#nodes-combustion-math","page":"Combustion","title":"Mathematical description","text":"The Combustion node enforces a mass/energy balance including residual energy loss. It also supports input blending restrictions using the limit dictionary, just like LimitedFlexibleInput.","category":"section"},{"location":"nodes/network/combustion/#nodes-combustion-math-var","page":"Combustion","title":"Variables","text":"The node uses the same variables as a standard NetworkNode:\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data","category":"section"},{"location":"nodes/network/combustion/#nodes-combustion-math-con","page":"Combustion","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of Combustion nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all Combustion types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/network/combustion/#nodes-combustion-math-con-stand","page":"Combustion","title":"Standard constraints","text":"Combustion utilize in general the standard constraints that are implemented for a NetworkNode node as described in the documentation of EnergyModelsBase. These standard constraints are:\n\nconstraints_capacity:\ntextttcap_usen t leq textttcap_instn t\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_opex_fixed:\ntextttopex_fixedn t_inv = opex_fixed(n t_inv) times textttcap_instn first(t_inv)\ntip: Why do we use `first()`\nThe variable textttcap_inst is declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacity in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\ntextttopex_varn t_inv = sum_t in t_inv opex_var(n t) times textttcap_usen t times scale_op_sp(t_inv t)\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified data of the nodes, see above.\n\nThe functions constraints_flow_in and constraints_flow_out receive new methods to handle, respectively, the input and output flow constraints:\n\nconstraints_flow_in\nInput energy balance (normalized by efficiency):\nsum_p in P^in fractextttflow_inn t pinputs(n p) =\ntextttcap_usen t\nInput share limit:\ntextttflow_inn t p leq\nleft(sum_q in P^in textttflow_inn t qright) times limits(n p)\nEnergy balance including residual heat:\nsum_p in P^in textttflow_inn t p =\ntextttcap_usen t +\nfractextttflow_outn t heat_resoutputs(n heat_res)\nThis ensures that total energy input equals the sum of useful output and waste heat output.\nconstraints_flow_out\nStandard output constraint (for non-residual outputs):\ntextttflow_outn t p = textttcap_usen t times outputs(n p)\nqquad forall p in outputs(n) setminus heat_res CO_2","category":"section"},{"location":"nodes/source/payasproducedppa/#nodes-payasproducedppa","page":"PayAsProducedPPA","title":"Pay-as-produced PPA energy source node","text":"Pay-as-produced PPA energy sources generate electricity from intermittent energy sources with a specific constraint on the variable operating expenses (OPEX) such that curtailed energy is also included in the OPEX. This node models a Power Purchase Agreement (PPA) contract.","category":"section"},{"location":"nodes/source/payasproducedppa/#nodes-payasproducedppa-fields","page":"PayAsProducedPPA","title":"Introduced type and its fields","text":"The PayAsProducedPPA is implemented as a subtype of AbstractNonDisRES extending the existing functionality defined in EnergyModelsRenewableProducers.\n\nThe fields of a PayAsProducedPPA are:\n\nid:\nThe field id is used for providing a name to the node. This is similar to the approach utilized in EnergyModelsBase.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal capacity of the node. If the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nprofile::TimeProfile:\nThe profile is used as a multiplier to the installed capacity to represent the maximum actual capacity in each operational period. The profile should be provided as OperationalProfile or at least as RepresentativeProfile. In addition, all values should be in the range 0 1.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, they are directly related to the specified output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of a strategic period as outlined on Utilize TimeStruct. It is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\noutput::Dict{<:Resource, <:Real}:\nThe field output includes Resources with their corresponding conversion factors as dictionaries. In the case of a pay-as-produced PPA energy source, output should include your electricity resource. In practice, you should use a value of 1.\ndata::Vector{Data}: An entry for providing additional data to the model. In the current version, it is only relevant for additional investment data when EnergyModelsInvestments is used.\nnote: Constructor for `PayAsProducedPPA`\nThe field data is not required as we include a constructor when the value is excluded.","category":"section"},{"location":"nodes/source/payasproducedppa/#nodes-payasproducedppa-math","page":"PayAsProducedPPA","title":"Mathematical description","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as\n\ntextttvar_exampleindex_1 index_2\n\nwith square brackets, while functions are represented as\n\nfunc_example(index_1 index_2)\n\nwith paranthesis.","category":"section"},{"location":"nodes/source/payasproducedppa/#nodes-payasproducedppa-math-var","page":"PayAsProducedPPA","title":"Variables","text":"The PayAsProducedPPA node types utilize all variables from the AbstractNonDisRES node type, as described on the page Optimization variables. The variables include:\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data.\ntextttcurtailment\n\nnote: Note\nNon-dispatchable renewable energy source nodes are not compatible with CaptureData. Hence, you can only provide EmissionsProcess to the node. It is our aim to include the potential for construction emissions in a latter stage","category":"section"},{"location":"nodes/source/payasproducedppa/#nodes-payasproducedppa-math-con","page":"PayAsProducedPPA","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of PayAsProducedPPA nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all PayAsProducedPPA types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/source/payasproducedppa/#nodes-payasproducedppa-math-con-stand","page":"PayAsProducedPPA","title":"Standard constraints","text":"PayAsProducedPPA utilize in general the standard constraints that are implemented for a AbstractNonDisRES node as described in the documentation of EnergyModelsRenewableProducers. These standard constraints are:\n\nconstraints_capacity: This function utilizes the method introduced for AbstractNonDisRes nodes to include the variable textttcurtailment:\ntextttcap_usen t leq textttcap_instn t\nand\ntextttcap_usen t + textttcurtailmentn t =\nprofile(n t) times textttcap_instn t\n\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investments. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_out:\ntextttflow_outn t p =\noutputs(n p) times textttcap_usen t\nqquad forall p  outputs(n) setminus textCO_2\nconstraints_opex_fixed:\ntextttopex_fixedn t_inv = opex_fixed(n t_inv) times textttcap_instn first(t_inv)\ntip: Why do we use `first()`\nThe variables textttcap_inst are declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacities in the first operational period of a given strategic period t_inv in the function constraints_opex_fixed.\nconstraints_data: This function is only called for specified data of the pay-as-produced PPA energy source, see above.\n\nThe function constraints_opex_var is extended with a new method to include the variable operating expenses also for the variable textttcurtailment:\n\ntextttopex_varn t_inv = sum_t  t_inv (textttcap_usen t + textttcurtailmentn t) times opex_var(n t) times scale_op_sp(t_inv t)\n\nThis change allows to model systems corresponding to the current regulation in which renewable power generation from solar PV or wind is paid, independently of the actual production.\n\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and strategic periods. It also takes into account potential operational scenarios and their probability as well as representative periods.","category":"section"},{"location":"nodes/network/minupdowntimenode/#nodes-minupdowntimenode","page":"MinUpDownTimeNode","title":"MinUpDownTimeNode","text":"MinUpDownTimeNode is a specialized NetworkNode type that introduces unit commitment logic including minimum up and down time constraints. It is useful for modeling dispatchable power plants or technologies where operation must adhere to minimum runtime constraints.\n\ntip: Example\nThis node is included in an example to demonstrate flexible demand.","category":"section"},{"location":"nodes/network/minupdowntimenode/#nodes-minupdowntimenode-fields","page":"MinUpDownTimeNode","title":"Introduced type and its fields","text":"The MinUpDownTimeNode extends the capabilities of a NetworkNode with binary status tracking and time-dependent logical constraints. It is implemented using integer variables to model on/off behavior and operational transitions.","category":"section"},{"location":"nodes/network/minupdowntimenode/#nodes-minupdowntimenode-fields-stand","page":"MinUpDownTimeNode","title":"Standard fields","text":"The standard fields are given as:\n\nid:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal capacity of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified input and output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of an investment period as outlined on Utilize TimeStruct.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\ninput::Dict{<:Resource,<:Real} and output::Dict{<:Resource,<:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries.\nCO‚ÇÇ cannot be directly specified, i.e., you cannot specify a ratio. If you use CaptureData, it is however necessary to specify CO‚ÇÇ as output, although the ratio is not important.\nAll values have to be non-negative.\ndata::Vector{<:Data}:\nOptional metadata (e.g., emissions or investment data). This is initialized to an empty array by default.\nnote: Constructor for `MinUpDownTimeNode`\nThe field data is not required as we include a constructor when the value is excluded.\nwarning: Using `CaptureData`\nIf you plan to use CaptureData for a MinUpDownTimeNode node, it is crucial that you specify your CO‚ÇÇ resource in the output dictionary. The chosen value is however not important as the CO‚ÇÇ flow is automatically calculated based on the process utilization and the provided process emission value. The reason for this necessity is that flow variables are declared through the keys of the output dictionary. Hence, not specifying CO‚ÇÇ as output resource results in not creating the corresponding flow variable and subsequent problems in the design.We plan to remove this necessity in the future. As it would most likely correspond to breaking changes, we have to be careful to avoid requiring major changes in other packages.\n\nwarning: Compatible time structure\nNote that this node cannot be used with OperationalScenarios or RepresentativePeriods.","category":"section"},{"location":"nodes/network/minupdowntimenode/#nodes-minupdowntimenode-fields-new","page":"MinUpDownTimeNode","title":"Additional fields","text":"MinUpDownTimeNode nodes add four additional fields compared to a NetworkNode:\n\nminUpTime::Real:\nMinimum number of operational periods the unit must remain on after being started.\nminDownTime::Real:\nMinimum number of operational periods the unit must remain off after being stopped.\nminCapacity::Real:\nMinimum power output when the unit is on. The value must be larger than zero.\nmaxCapacity::Real:\nMaximum power output when the unit is on (usually aligned with cap). The value must not be less than minCapacity.\n\ntip: Tip\nThe fields minUpTime and minDownTime are defined in terms of operational period durations and should be consistent with the time granularity of the model.","category":"section"},{"location":"nodes/network/minupdowntimenode/#nodes-minupdowntimenode-math","page":"MinUpDownTimeNode","title":"Mathematical description","text":"MinUpDownTimeNode introduces integer-based logic and sequencing constraints, in addition to standard flow and capacity formulations of NetworkNodes.","category":"section"},{"location":"nodes/network/minupdowntimenode/#nodes-minupdowntimenode-math-var","page":"MinUpDownTimeNode","title":"Variables","text":"In addition to variables used in a NetworkNode:\n\ntextttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttflow_out\ntextttemissions_node if EmissionsData is added to the field data\n\nThe following binary variables are introduced for unit commitment behavior:\n\ntexttton_offn t in 01:\nIndicates if the unit is operating during time step t.\ntextttonswitchn t in 01:\nIndicates a startup at time step t.\ntextttoffswitchn t in 01:\nIndicates a shutdown at time step t.","category":"section"},{"location":"nodes/network/minupdowntimenode/#nodes-minupdowntimenode-math-con","page":"MinUpDownTimeNode","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of MinUpDownTimeNode nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all MinUpDownTimeNode types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/network/minupdowntimenode/#nodes-minupdowntimenode-math-con-stand","page":"MinUpDownTimeNode","title":"Standard constraints","text":"MinUpDownTimeNode utilize in general the standard constraints that are implemented for a NetworkNode node as described in the documentation of EnergyModelsBase. These standard constraints are:\n\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_in:\ntextttflow_inn t p = inputs(n p) times textttcap_usen t\nqquad forall p in inputs(n)\nconstraints_flow_out:\ntextttflow_outn t p =\noutputs(n p) times textttcap_usen t\nqquad forall p in outputs(n) setminus textCO_2\nconstraints_opex_fixed:\ntextttopex_fixedn t_inv = opex_fixed(n t_inv) times textttcap_instn first(t_inv)\ntip: Why do we use `first()`\nThe variable textttcap_inst is declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacity in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\ntextttopex_varn t_inv = sum_t in t_inv opex_var(n t) times textttcap_usen t times scale_op_sp(t_inv t)\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified data of the nodes, see above.\n\nThe function constraints_capacity receives a new method to handle the minimum up and down time constraints:\n\nOn/off transition logic:\ntexttton_offn t =\ntexttton_offn t_prev - textttoffswitchn t + textttonswitchn t\nMutual exclusivity of on/off switching:\ntextttonswitchn t + textttoffswitchn t leq 1\nMinimum up time:\nsum_tau = t+1^t+M-1 textttonswitchn tau leq 1\nand\ntextttoffswitchn t leq 1 - sum_tau = t+1^t+M-1 textttonswitchn tau\nMinimum down time:\nsum_tau = t+1^t+N-1 textttoffswitchn tau leq 1\nand\ntextttonswitchn t leq 1 - sum_tau = t+1^t+N-1 textttoffswitchn tau\nCapacity conditional on on/off status:\ntextttcap_usen t leq texttton_offn t times nmaxCapacity\ntextttcap_usen t geq texttton_offn t times nminCapacity\nUpper bound by installed capacity:\ntextttcap_usen t leq textttcap_instn t\nInstalled capacity fixed to defined value:\ntextttcap_instn t = capacity(n t)\n\nwarning: Mixed-integer complexity\nThe MinUpDownTimeNode introduces binary variables and logical constraints that make the model a Mixed-Integer Linear Program (MILP). This may significantly increase solve time and model complexity.","category":"section"},{"location":"library/internals/methods-fields/#lib-int-met_field","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"","category":"section"},{"location":"library/internals/methods-fields/#lib-int-met_field-idx","page":"Methods - Accessing fields","title":"Index","text":"Pages = [\"methods-fields.md\"]","category":"section"},{"location":"library/internals/methods-fields/#lib-int-met_field-PeriodDemandSink","page":"Methods - Accessing fields","title":"PeriodDemandSink types","text":"","category":"section"},{"location":"library/internals/methods-fields/#lib-int-met_field-ActivationCostNode","page":"Methods - Accessing fields","title":"ActivationCostNode types","text":"","category":"section"},{"location":"library/internals/methods-fields/#lib-int-met_field-CapacityCostLink","page":"Methods - Accessing fields","title":"CapacityCostLink types","text":"","category":"section"},{"location":"library/internals/methods-fields/#lib-int-met_field-Combustion","page":"Methods - Accessing fields","title":"Combustion types","text":"","category":"section"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.period_demand","page":"Methods - Accessing fields","title":"EnergyModelsFlex.period_demand","text":"period_demand(n::AbstractPeriodDemandSink)\nperiod_demand(n::AbstractPeriodDemandSink, i::Int)\n\nReturns the period demand of AbstractPeriodDemandSink n as Array or in demand period i.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.period_length","page":"Methods - Accessing fields","title":"EnergyModelsFlex.period_length","text":"period_length(n::AbstractPeriodDemandSink)\n\nReturns the length of the demand period of AbstractPeriodDemandSink n.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.period_index","page":"Methods - Accessing fields","title":"EnergyModelsFlex.period_index","text":"period_index(n::AbstractPeriodDemandSink, t)\n\nReturns the index of the period (e.g., day) that a operational period t belongs to.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.number_of_periods","page":"Methods - Accessing fields","title":"EnergyModelsFlex.number_of_periods","text":"number_of_periods(n::AbstractPeriodDemandSink)\nnumber_of_periods(n::AbstractPeriodDemandSink, ùíØ::TimeStructure)\n\nReturns the number of periods for a PeriodDemandSink n. If a TimeStructure is provided it calculates it based on the chosen time structure.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.activation_consumption","page":"Methods - Accessing fields","title":"EnergyModelsFlex.activation_consumption","text":"activation_consumption(n::ActivationCostNode)\nactivation_consumption(n::ActivationCostNode, p::Resource)\n\nReturns the demand during activation of ActivationCostNode n as dictionary or for input Resource p. If p is not included in the dictionary, it returns a value of 0.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.cap_price_periods","page":"Methods - Accessing fields","title":"EnergyModelsFlex.cap_price_periods","text":"cap_price_periods(l::CapacityCostLink)\n\nReturns the number of sub-periods within a year for which a price is calculated of a capacity cost link l.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.cap_resource","page":"Methods - Accessing fields","title":"EnergyModelsFlex.cap_resource","text":"cap_resource(l::CapacityCostLink)\n\nReturns the resource for which the capacity is limited and has a price of a capacity cost link l.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.cap_price","page":"Methods - Accessing fields","title":"EnergyModelsFlex.cap_price","text":"cap_price(l::CapacityCostLink)\n\nReturns the price per unit of maximum capacity usage of a capacity cost link l.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.limits","page":"Methods - Accessing fields","title":"EnergyModelsFlex.limits","text":"limits(n::Combustion, p::Resource)\n\nReturns the limit of a resource p for a Combustion node n.\n\n\n\n\n\nlimits(n::Combustion)\n\nReturns all resources with defined limits for a Combustion node n.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsFlex.heat_resource","page":"Methods - Accessing fields","title":"EnergyModelsFlex.heat_resource","text":"heat_resource(n::Combustion)\n\nReturns the heat residual resource of a Combustion node n.\n\n\n\n\n\n","category":"function"},{"location":"links/capacitycostlink/#links-CapacityCostLink","page":"CapacityCostLink","title":"CapacityCostLink","text":"CapacityCostLink links model the transport of energy between two nodes with capacity-dependent operational costs applied to a specified resource. Unlike standard Direct links, they enable cost modeling based on maximum capacity utilization over defined time periods. This is useful for applications such as transmission networks, pipelines, or interconnectors where usage fees scale with peak capacity demands.\n\nIn addition, they only allow the transport of a single, specified Resource.","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-fields","page":"CapacityCostLink","title":"Introduced type and its fields","text":"CapacityCostLink is implemented as equivalent to an abstract type Link. Hence, it utilizes the same functions declared in EnergyModelsBase.\n\nwarning: Application of the link\nThe current implementation is not very flexible with respect to the chosen time structure. Specifically, if you use OperationalScenarios, RepresentativePeriods, or differing operational structures within your TwoLevel, you must be careful when choosing the parameter cap_price_periods.","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-fields-stand","page":"CapacityCostLink","title":"Standard fields","text":"CapacityCostLink has the following standard fields, equivalent to a Direct link:\n\nid :\nThe field id is only used for providing a name to the link.\nfrom::Node :\nThe node from which there is flow into the link.\nto::Node :\nThe node to which there is flow out of the link.\nformulation::Formulation :\nThe used formulation of links. If not specified, a Linear link is assumed.\nnote: Different formulations\nThe current implementation of links does not provide another formulation. Our aim is in a later stage to allow the user to switch fast through different formulations to increase or decrese the complexity of the model.","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-fields-new","page":"CapacityCostLink","title":"Additional fields","text":"The following additional fields are included for CapacityCostLink links:\n\ncap::TimeProfile :\nThe maximum transport capacity of the link for the cap_resource. If the link should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\ncap_price::TimeProfile :\nThe price per unit of maximum capacity usage over the sub-periods. This value is averaged over sub-periods as defined by cap_price_periods. All values have to be non-negative.\ncap_price_periods::Int64 :\nThe number of sub-periods within a year for which the capacity cost is calculated. This allows modeling of varying peak demands across seasons. The value must be positive.\ntip: Number of sub-periods\nFor investment periods with many operational periods, consider increasing the number of cap_price_periods. The CapacityCostLink capacity constraints couple operational periods and can significantly increase solve time. Splitting the horizon into multiple sub-periods reduces this coupling and often makes the problem much easier to solve. In some cases, this also means using more than one capacity price period even if capacity costs occur only annually in reality, depending on model size and complexity.\ncap_resource::Resource :\nThe Resource for which capacity-dependent costs are applied. This Resource is the only transported Resource by a CapacityCostLink.\ndata::Vector{<:ExtensionData}:\nAn entry for providing additional data to the model. In the current version, it is used for providing additional investment data when EnergyModelsInvestments is used.\nnote: Constructor for `CapacityCostLink`\nThe field data is not required as we include constructors when the value is excluded.","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-math","page":"CapacityCostLink","title":"Mathematical description","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as\n\ntextttvar_exampleindex_1 index_2\n\nwith square brackets, while functions are represented as\n\nfunc_example(index_1 index_2)\n\nwith paranthesis.","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-math-var","page":"CapacityCostLink","title":"Variables","text":"","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-math-var-stand","page":"CapacityCostLink","title":"Standard variables","text":"CapacityCostLink utilizes standard variables from the Link type, as described on the page Optimization variables:\n\ntextttlink_in\ntextttlink_out\ntextttlink_cap_inst","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-math-var-add","page":"CapacityCostLink","title":"Additional variables","text":"Two additional variables track capacity utilization and associated costs over sub-periods:\n\ntextttccl_max_cap_usel t_sub: Maximum capacity usage in sub-period t_sub for link l.\ntextttccl_cap_costl t_sub: Operational cost in sub-period t_sub for link l.","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-math-con","page":"CapacityCostLink","title":"Constraints","text":"","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-math-con-stand","page":"CapacityCostLink","title":"Standard constraints","text":"The applied standard constraint for capacity installed is:\n\ntextttlink_cap_instl t = capacity(l t)\n\nand the no-loss constraint\n\ntextttlink_outl t p = textttlink_inl t p quad forall p in inputs(l)","category":"section"},{"location":"links/capacitycostlink/#links-CapacityCostLink-math-con-add","page":"CapacityCostLink","title":"Additional constraints","text":"All additional constraints are created within a new method for the function create_link.\n\nThe capacity utilization constraint tracks the maximum usage within each sub-period:\n\ntextttlink_inl t cap_resource(l) leq textttccl_max_cap_usel t_sub\n\nThe capacity cost is calculated as:\n\ntextttccl_cap_costl t_sub = textttccl_max_cap_usel t_sub times overlinecap_price(l t_sub)\n\nwhere overlinecap_price is the average capacity price over the sub-period.\n\nFinally, costs are aggregated to each strategic period:\n\ntextttlink_opex_varl t_inv = sum_t_sub in t_inv textttccl_cap_costl t_sub\n\nIn addition, the energy flow of the constrained resource should not exceed the maximum pipe capacity, which is included through the following constraint:\n\ntextttflow_inl t cap_resource(l) leq textttlink_cap_instl t","category":"section"},{"location":"manual/NEWS/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"manual/NEWS/#Version-0.2.10-(2026-01-05)","page":"Release notes","title":"Version 0.2.10 (2026-01-05)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancements","page":"Release notes","title":"Enhancements","text":"Added the new link CapacityCostLink.\nAdded the nodes InflexibleSource and FlexibleOutput.","category":"section"},{"location":"manual/NEWS/#Adjustments","page":"Release notes","title":"Adjustments","text":"Removed ext/EMGUIExt/descriptive_names.yml as this will now be provided directly in EnergyModelsGUI.\nRemoved docs/src/example/flexible_demand.md as the markdown versions of the example files are now generated automatically (and these are thus added to the .gitignore-file).","category":"section"},{"location":"manual/NEWS/#Version-0.2.9-(2025-07-08)","page":"Release notes","title":"Version 0.2.9 (2025-07-08)","text":"Adjusted to EnergyModelsBase v0.9.0:\nIncreased version number for EMB.\nReplaced variables_node with variables_element.","category":"section"},{"location":"manual/NEWS/#Bugfix","page":"Release notes","title":"Bugfix","text":"Fixed a bug in MultipleInputStrat nodes:\nThe variables were declared over all input resources of a nodes of this type.\nAs a consequence, unconstrained variables were declared when multiple nodes with differing inputs were included.\nIn the worst case, this could lead to an unbound problem if the surplus penalty was negative.","category":"section"},{"location":"manual/NEWS/#Version-0.2.8-(2025-07-04)","page":"Release notes","title":"Version 0.2.8 (2025-07-04)","text":"","category":"section"},{"location":"manual/NEWS/#Public-release-on-GitHub","page":"Release notes","title":"Public release on GitHub","text":"Released the exisiting version so that case studies in the project FLEX4FACT are running without any problems.\nRelease depends on old versions of EnergyModelsBase.\nIt is planned to update the model to the latest version within a short period of time.","category":"section"},{"location":"manual/NEWS/#Version-0.2.7-(2025-01-14)","page":"Release notes","title":"Version 0.2.7 (2025-01-14)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement","page":"Release notes","title":"Enhancement","text":"Add a Combustion node","category":"section"},{"location":"manual/NEWS/#Version-0.2.6-(2025-01-18)","page":"Release notes","title":"Version 0.2.6 (2025-01-18)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement-2","page":"Release notes","title":"Enhancement","text":"Added more checks, documentation and tests.\nReplaced Combustion with LimitedFlexibleInput where the inverse convention of the conversion ratio is used for the input resources.\nRenamed AbstractMachineryDemand to AbstractMultipleInputSinkStrat with AbstractMultipleInputSink as supertype.\nRenamed BinaryMachineryDemand and ContinuousMachineryDemand to BinaryMultipleInputSinkStrat and ContinuousMultipleInputSinkStrat, respectively. Also generalized the electrification variable to the variable input_frac_strat which enables more input resources.\nAdd documentation, NEWS and README.\nAdjusted code to comply with Aqua requirements and to comply with EMX standards.\nAdded descriptive names for variables introduced in EnergyModelsFlex to be used in EnergyModelsGUI.\nAdded new nodes for SPS, remove redundant constraint for PayAsProducedPPA and dispatch on AbstractNonDisRES (instead of Source).\nImprove documentation of LoadShiftingNode, use Int-type where appropriate and fix minor bug in load shift constraints.","category":"section"},{"location":"manual/NEWS/#Version-0.2.5-(2024-11-12)","page":"Release notes","title":"Version 0.2.5 (2024-11-12)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement-3","page":"Release notes","title":"Enhancement","text":"Add SPS nodes.","category":"section"},{"location":"manual/NEWS/#Version-0.2.4-(2024-11-01)","page":"Release notes","title":"Version 0.2.4 (2024-11-01)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement-4","page":"Release notes","title":"Enhancement","text":"Add PayAsProducedPPA node.","category":"section"},{"location":"manual/NEWS/#Version-0.2.3-(2024-10-29)","page":"Release notes","title":"Version 0.2.3 (2024-10-29)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement-5","page":"Release notes","title":"Enhancement","text":"Version update.","category":"section"},{"location":"manual/NEWS/#Version-0.2.2-(2024-10-10)","page":"Release notes","title":"Version 0.2.2 (2024-10-10)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement-6","page":"Release notes","title":"Enhancement","text":"Create an abstract base type for PeriodDemandSink.","category":"section"},{"location":"manual/NEWS/#Version-0.2.1-(2024-10-09)","page":"Release notes","title":"Version 0.2.1 (2024-10-09)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement-7","page":"Release notes","title":"Enhancement","text":"Add demand_sink_surplus slack variable.","category":"section"},{"location":"manual/NEWS/#Version-0.2.0-(2024-10-08)","page":"Release notes","title":"Version 0.2.0 (2024-10-08)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement-8","page":"Release notes","title":"Enhancement","text":"BatteryStorage cant be included before it is updated to EnergyModelsBase v0.8.0.","category":"section"},{"location":"manual/NEWS/#Version-0.1.1-(2024-06-18)","page":"Release notes","title":"Version 0.1.1 (2024-06-18)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement-9","page":"Release notes","title":"Enhancement","text":"Make BatteryStorage work when included in investment models, note that investments in BatteryStorage needs further development.","category":"section"},{"location":"manual/NEWS/#Version-0.1.0-(2024-04-16)","page":"Release notes","title":"Version 0.1.0 (2024-04-16)","text":"","category":"section"},{"location":"manual/NEWS/#Initial-(skeleton)-version","page":"Release notes","title":"Initial (skeleton) version","text":"Make it into a package.","category":"section"},{"location":"#EnergyModelsFlex","page":"Home","title":"EnergyModelsFlex","text":"","category":"section"},{"location":"#What-is-flexibility-in-energy-systems?","page":"Home","title":"What is flexibility in energy systems?","text":"Flexibility in energy systems refers to the ability to adapt generation, consumption, or conversion in response to variability in supply and demand‚Äîespecially with growing shares of intermittent renewable sources like wind and solar. Flexibility can be implemented in several forms:\n\nTemporal flexibility: shifting electricity consumption or production across time (e.g. demand response, storage).\nInput flexibility: using different fuels or resources to meet the same service (e.g. fuel-switching boilers).\nOperational flexibility: including start-up/shutdown constraints, minimum running times, or part-load efficiency.\nNetwork and conversion flexibility: controlling flows across interconnected energy carriers (e.g. heat and electricity).\n\nEnergyModelsFlex introduces custom nodes that allow modelers to represent these dimensions of flexibility in a structured, modular way.\n\n","category":"section"},{"location":"#Implemented-flexible-node-types","page":"Home","title":"Implemented flexible node types","text":"This package provides several node types that extend the EnergyModelsX interface:","category":"section"},{"location":"#Source-Nodes","page":"Home","title":"Source Nodes","text":"PayAsProducedPPA: A source with contractual constraints typical for renewable power purchase agreements (PPA).","category":"section"},{"location":"#Sink-Nodes","page":"Home","title":"Sink Nodes","text":"PeriodDemandSink: Allows demand to be met flexibly within a defined time period (e.g. daily energy use).\nLoadShiftingNode: Supports discrete batch shifting across time within allowed work shifts.\nMultipleInputSink: Enables flexible use of multiple input resources to meet demand.\nBinaryMultipleInputSinkStrat: Input choice from multiple fuels using binary (exclusive) decisions per period.\nContinuousMultipleInputSinkStrat: Allows input blending over strategic periods using continuous fractions.","category":"section"},{"location":"#Network-Nodes","page":"Home","title":"Network Nodes","text":"MinUpDownTimeNode: Models units with startup/shutdown constraints and minimum uptime/downtime.\nActivationCostNode: Includes additional input costs on startup (e.g. ignition fuel).\nLimitedFlexibleInput: Restricts the share of individual input fuels in a multi-input conversion process.\nCombustion: Enforces full energy balances including residual heat losses.","category":"section"},{"location":"#Storage","page":"Home","title":"Storage","text":"StorageEfficiency: Allows modeling of time- and state-dependent storage efficiency losses.\n\n","category":"section"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"Pages = [\n    \"manual/quick-start.md\",\n    \"examples/flexible_demand.md\",\n    \"manual/NEWS.md\",\n]\nDepth = 1","category":"section"},{"location":"#How-to-guides","page":"Home","title":"How to guides","text":"Pages = [\n    \"how-to/contribute.md\",\n    \"how-to/utilize.md\",\n]\nDepth = 1","category":"section"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"Pages = [\n    \"library/public.md\",\n    \"library/internals/types.md\",\n    \"library/internals/methods-fields.md\",\n    \"library/internals/methods-EMF.md\",\n    \"library/internals/methods-EMB.md\",\n]\nDepth = 1","category":"section"},{"location":"#EnergyModelsFlex","page":"Home","title":"EnergyModelsFlex","text":"EnergyModelsFlex is a Julia package that extends the EnergyModelsX energy system modeling framework with additional node types that capture different aspects of flexibility in energy systems.\n\nThis package provides a series of technology node types for EnergyModelsX enabling energy and process flexibility modeling.\n\n\n\n\n\n","category":"module"},{"location":"library/public/#lib-pub-nodes","page":"Public","title":"Nodes","text":"","category":"section"},{"location":"library/public/#Index","page":"Public","title":"Index","text":"Pages = [\"public.md\"]","category":"section"},{"location":"library/public/#lib-pub-sink-node","page":"Public","title":"Sink Node types","text":"The following sink node types are implemented in the EnergyModelsFlex:","category":"section"},{"location":"library/public/#lib-pub-source-node","page":"Public","title":"Source Node types","text":"The following source node type is implemented in the EnergyModelsFlex:","category":"section"},{"location":"library/public/#lib-pub-network-node","page":"Public","title":"Network Node types","text":"The following network node types are implemented in the EnergyModelsFlex:","category":"section"},{"location":"library/public/#lib-pub-storage-node","page":"Public","title":"Storage Node types","text":"The following storage node types are implemented in the EnergyModelsFlex:","category":"section"},{"location":"library/public/#lib-pub-link","page":"Public","title":"Link types","text":"The following link types are implemented in the EnergyModelsFlex:","category":"section"},{"location":"library/public/#EnergyModelsFlex.PeriodDemandSink","page":"Public","title":"EnergyModelsFlex.PeriodDemandSink","text":"struct PeriodDemandSink <: AbstractPeriodDemandSink\n\nA PeriodDemandSink is a Sink that has a demand that can be satisfied any time during a period of defined length. If the chosen time structure has operational periods of  a duration of 1 hour and the  demand should be fulfilled daily, period_length should be 24. The demand for each day is then set as an array as the period_demand field. The cap field is the maximum capacity that can be fulfilled in each operational period.\n\nFields\n\nid::Any is the name/identifier of the node.\nperiod_length::Int is the number of periods in which the period demand can be satisfied.\nperiod_demand::Array{<:Real} is the demand within each of the periods.\ncap::TimeProfile is the installed capacity.\npenalty::Dict{Symbol,<:TimeProfile} are penalties for surplus or deficits. The dictionary requires the  fields :surplus and :deficit.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\ndata::Vector{Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.MultipleInputSink","page":"Public","title":"EnergyModelsFlex.MultipleInputSink","text":"struct MultipleInputSink <: AbstractMultipleInputSink\n\nA Sink node with multiple inputs for satisfying the demand.\n\nContrary to a standard sink, it is possible to utilize the individual input resources independent of each other.\n\nFields\n\nid::Any is the name/identifier of the node.\ncap::TimeProfile is the demand.\npenalty::Dict{Symbol,<:TimeProfile} are penalties for surplus or deficits. The dictionary requires the  fields :surplus and :deficit.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\ndata::Vector{<:Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.BinaryMultipleInputSinkStrat","page":"Public","title":"EnergyModelsFlex.BinaryMultipleInputSinkStrat","text":"struct BinaryMultipleInputSinkStrat <: AbstractMultipleInputSinkStrat\n\nA Sink node with multiple inputs for satisfying the demand.\n\nThis type of node corresponds to an energy service demand where several different energy carriers can satisfy the demand, but only one resource at the time (for each strategic period).\n\nFields\n\nid::Any is the name/identifier of the node.\ncap::TimeProfile is the demand.\npenalty::Dict{Symbol,<:TimeProfile} are penalties for surplus or deficits. The dictionary requires the  fields :surplus and :deficit.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\ndata::Vector{<:Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\nwarning: Investment options\nIt is not possible to utilize investments for a BinaryMultipleInputSinkStrat as this would introduce bilinear constraints.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.ContinuousMultipleInputSinkStrat","page":"Public","title":"EnergyModelsFlex.ContinuousMultipleInputSinkStrat","text":"struct ContinuousMultipleInputSinkStrat <: AbstractMultipleInputSinkStrat\n\nA Sink node with multiple inputs for satisfying the demand.\n\nThis type of node corresponds to an energy service demand where several different energy carriers can satisfy the demand after the supplied energy. The fraction of the input resources are given as a variable to be optimized (for each strategic period).\n\nFields\n\nid::Any is the name/identifier of the node.\ncap::TimeProfile is the demand.\npenalty::Dict{Symbol,<:TimeProfile} are penalties for surplus or deficits. The dictionary requires the  fields :surplus and :deficit.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\ndata::Vector{<:Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\nwarning: Investment options\nIt is not possible to utilize investments for a BinaryMultipleInputSinkStrat as this would introduce bilinear constraints.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.LoadShiftingNode","page":"Public","title":"EnergyModelsFlex.LoadShiftingNode","text":"LoadShiftingNode <: EMB.Sink\n\nA Sink node where the demand can be altered by load shifting. The load shifting is based on the assumption that the production happens in discrete batches. A representative batch is defined with a magnitude and a duration. A load shift will in this case mean subtracting the consumption of a representative batch from the original consumption at one time slot and adding it on another timeslot. The node is furthermore build for a case where the working shifts dictates when the batches may be initiated. Thus the timesteps where such a batch is allowed to be added/subtracted is defined by the load_shift_times field. The load_shift_times is further grouped together in groups of load_shift_times_per_period, for which the representative batches can only be shifted within this group.\n\nwarning: Warning\nThe node uses indexing of the time steps and is as of now not made to handle timesteps of different durations.\n\nFields\n\nid::Any is the name/identifier of the node.\ncap::TimeProfile is the original Demand (before load shifting).\npenalty::Dict{Symbol, <:TimeProfile} (not used) are penalties for surplus or deficits. Requires the fields :surplus and :deficit.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\nload_shift_times::Vector{<:Int} are the indices of the time structure that bulks of loads may be shifted from/to.\nload_shifts_per_period::Int the upper limit of the number of load shifts within the period defined by load_shift_times_per_period that can be performed for a given period (defined by the number of timeslots that can be shifted - n_loadshift).\nload_shift_duration::Int the number of operational periods in each load shift.\nload_shift_magnitude::Real the magnitude for each operational period that is load shifted.\nload_shift_times_per_period::Int the number of timeslots (from the loadshifttimes) that can be shifted.\ndata::Vector{Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.PayAsProducedPPA","page":"Public","title":"EnergyModelsFlex.PayAsProducedPPA","text":"PayAsProducedPPA <: AbstractNonDisRES\n\nA pay-as-produced ppa energy source. It extends the existing AbstractNonDisRES node through including a constraint on the opex_var such that curtailed energy is also included in the opex.\n\nFields\n\nid is the name/identifyer of the node.\ncap::TimeProfile is the installed capacity.\nprofile::TimeProfile is the power production in each operational period as a ratio of the installed capacity at that time.\nopex_var::TimeProfile is the variable operating expense per energy unit produced.\nopex_fixed::TimeProfile is the fixed operating expense.\noutput::Dict{Resource, Real} are the generated Resources, normally Power.\ndata::Vector{Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.InflexibleSource","page":"Public","title":"EnergyModelsFlex.InflexibleSource","text":"struct InflexibleSource <: EMB.Source\n\nAn inflexible Source node with fixed capacity. The inflexible Source node represents a source with a  fixed capacity usage. Note, that if you include investments, you can only use cap as TimeProfile a  FixedProfile or StrategicProfile.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per per capacity usage through the variable :cap_use.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\noutput::Dict{<:Resource,<:Real} are the generated  Resources with conversion value Real.\ndata::Vector{<:ExtensionData} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.MinUpDownTimeNode","page":"Public","title":"EnergyModelsFlex.MinUpDownTimeNode","text":"MinUpDownTimeNode{} <: UnitCommitmentNode\n\nMinUpDownTimeNode is a specialized NetworkNode type that introduces unit commitment logic including minimum up and down time constraints.  It is useful for modeling dispatchable power plants or technologies where operation must adhere to minimum runtime constraints.\n\nFields\n\nid: Identifier or name for the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per per capacity usage through the variable :cap_use.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource,<:Real} are the generated Resources with conversion value Real.\nminUpTime::Real is the minimum number of operational periods the unit must remain on after being started.\nminDownTime::Real is the minimum number of operational periods the unit must remain off after being stopped.\nminCapacity::Real is the minimum power output when the unit is on.\nmaxCapacity::Real is the maximum power output when the unit is on (usually aligned with cap).\ndata::Vector{Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.ActivationCostNode","page":"Public","title":"EnergyModelsFlex.ActivationCostNode","text":"ActivationCostNode{} <: UnitCommitmentNode\n\nActivationCostNode is a specialized NetworkNode that introduces unit commitment logic with additional fuel or resource costs incurred upon startup.  It models technologies that consume extra input when switching on, such as combustion turbines or thermal boilers.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per per capacity usage through the variable :cap_use.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource,<:Real} are the generated Resources with conversion value Real.\nactivation_time::Real: Duration of activation effect (currently used to inform activation logic in customized formulations).\nactivation_consumption::Dict{<:Resource,<:Real} are the additional input resources required when the unit switches on with their absolute demand.\ndata::Vector{Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.LimitedFlexibleInput","page":"Public","title":"EnergyModelsFlex.LimitedFlexibleInput","text":"LimitedFlexibleInput <: NetworkNode\n\nA LimitedFlexibleInput node. The LimitedFlexibleInput utilizes a linear, time independent conversion rate of the input Resources to the output Resources, subject to the available capacity and limitation of the Resources given by the limit field.\n\nAs opposed to the RefNetworkNode in EnergyModelsBase, the LimitedFlexibleInput node introduces a limit on the fraction a given resource can contribute to the total inflow.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per per capacity usage through the variable :cap_use.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\nlimit::Dict{<:Resource, <:Real} are the limits for each Resources of the total input.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource,<:Real} are the generated Resources with conversion value Real.\ndata::Vector{Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.Combustion","page":"Public","title":"EnergyModelsFlex.Combustion","text":"Combustion <: NetworkNode\n\nA Combustion node. The Combustion is similar to LimitedFlexibleInputs but requires energy balances in the sense that the output heat_res captures the lost energy.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per per capacity usage through the variable :cap_use.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\nlimit::Dict{<:Resource, <:Real} are the limits for each Resources of the total input.\nheat_res::Resource the residual heat resource.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource,<:Real} are the generated Resources with conversion value Real.\ndata::Vector{Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.FlexibleOutput","page":"Public","title":"EnergyModelsFlex.FlexibleOutput","text":"FlexibleOutput <: NetworkNode\n\nA FlexibleOutput node.\n\nThe FlexibleOutput is similar to NetworkNodes but introduces flexibility in the output as the capacity use is given by the sum of these.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per per capacity usage through the variable :cap_use.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity through the variable :cap_inst.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource,<:Real} are the generated Resources with conversion value Real.\ndata::Vector{Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.ElectricBattery","page":"Public","title":"EnergyModelsFlex.ElectricBattery","text":"ElectricBattery <: EMB.Storage\n\nElectric battery node\n\nc_rate:\ncoloumbic_eff:\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.StorageEfficiency","page":"Public","title":"EnergyModelsFlex.StorageEfficiency","text":"StorageEfficiency{T} <: EMB.Storage{T}\n\nA StorageEfficiency node which enables storage efficiency control compared to RefStorage{T}.\n\nIt is designed as a parametric type through the type parameter T to differentiate between different cyclic behaviours. Note that the parameter T is only used for dispatching, but does not carry any other information. Hence, it is simple to fast switch between different StorageBehaviors.\n\nThe current implemented cyclic behaviours are CyclicRepresentative and CyclicStrategic.\n\nFields\n\nid is the name/identifier of the node.\ncharge::UnionCapacity are the charging parameters of the Storage node. Depending on the chosen type, the charge parameters can include variable OPEX and/or fixed OPEX. They must include a capacity.\nlevel::UnionCapacity are the level parameters of the Storage node. Depending on the chosen type, the level parameters can include variable OPEX and/or fixed OPEX. They must include a capacity.\nstor_res::Resource is the stored Resource.\ninput::Dict{<:Resource,<:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource,<:Real} are the generated Resources with conversion value Real.\ndata::Vector{<:ExtensionData} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsFlex.CapacityCostLink","page":"Public","title":"EnergyModelsFlex.CapacityCostLink","text":"CapacityCostLink\n\nA link between two nodes with costs on the link usage for the resource cap_resource. All other resources have no costs associated with their usage (follows the Direct).\n\nFields\n\nid is the name/identifier of the link.\nfrom::Node is the node from which there is flow into the link.\nto::Node is the node to which there is flow out of the link.\ncap::TimeProfile is the capacity of the link for the cap_resource.\ncap_price::TimeProfile is the price of capacity usage for the cap_resource.\ncap_price_periods::Int64 is the number of sub periods of a year.\ncap_resource::Resource is the resource used by CapacityCostLink\nformulation::Formulation is the used formulation of links. The field formulation is conditional through usage of a constructor.\ndata::Vector{<:ExtensionData} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\n\n\n\n\n\n","category":"type"},{"location":"nodes/network/limitedflexibleinput/#nodes-limitedflexibleinput","page":"LimitedFlexibleInput","title":"LimitedFlexibleInput node","text":"LimitedFlexibleInput nodes are a specialized form of NetworkNodes that support multiple input resources with a fixed output structure, but limit how much each individual input can contribute to the total inflow. This is particularly useful for modeling constraints such as fuel blend caps, quality requirements, or policy-imposed input fractions.","category":"section"},{"location":"nodes/network/limitedflexibleinput/#nodes-limitedflexibleinput-fields","page":"LimitedFlexibleInput","title":"Introduced type and its fields","text":"The LimitedFlexibleInput node builds on the NetworkNode implementation by adding an additional limit field, which restricts the fractional contribution of each input Resource to the total input flow.","category":"section"},{"location":"nodes/network/limitedflexibleinput/#nodes-limitedflexibleinput-fields-stand","page":"LimitedFlexibleInput","title":"Standard fields","text":"The standard fields are given as:\n\nid:\nThe field id is only used for providing a name to the node.\ncap::TimeProfile:\nThe installed capacity corresponds to the nominal capacity of the node.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified input and output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nFixed operating expenses applied per unit of installed capacity and investment period duration.\ninput::Dict{<:Resource,<:Real} and output::Dict{<:Resource,<:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries.\nCO‚ÇÇ cannot be directly specified, i.e., you cannot specify a ratio. If you use CaptureData, it is however necessary to specify CO‚ÇÇ as output, although the ratio is not important.\nAll values have to be non-negative.\ndata::Vector{<:Data}:\nAn entry for providing additional data to the model. In the current version, it is used for both providing EmissionsData and additional investment data when EnergyModelsInvestments is used.\nnote: Constructor for `LimitedFlexibleInput`\nThe field data is not required as we include a constructor when the value is excluded.\nwarning: Using `CaptureData`\nIf you plan to use CaptureData for a LimitedFlexibleInput node, it is crucial that you specify your CO‚ÇÇ resource in the output dictionary. The chosen value is however not important as the CO‚ÇÇ flow is automatically calculated based on the process utilization and the provided process emission value. The reason for this necessity is that flow variables are declared through the keys of the output dictionary. Hence, not specifying CO‚ÇÇ as output resource results in not creating the corresponding flow variable and subsequent problems in the design.We plan to remove this necessity in the future. As it would most likely correspond to breaking changes, we have to be careful to avoid requiring major changes in other packages.","category":"section"},{"location":"nodes/network/limitedflexibleinput/#nodes-limitedflexibleinput-fields-new","page":"LimitedFlexibleInput","title":"Additional fields","text":"LimitedFlexibleInput nodes add a single additional field compared to a NetworkNode:\n\nlimit::Dict{<:Resource,<:Real}:\nA dictionary that sets the maximum share each input resource can contribute to the total inflow. Resources which are specified in the input dictionary, but not in the limit dictionary will be treated as unconstrained. This corresponds to a value of 1 in the limit dictionary. All values should be in the range 0 1.\ntip: Tip\nThe limit field can be used to enforce regulatory blending requirements (e.g., max 30 % coal in a hybrid boiler), or to simulate physical limitations such as combustion chamber design.\nnote: Total inflow dependency\nThe limit applies relative to the total inflow, not to the output or installed capacity. This makes it suitable for mix-based constraints, such as resource quota obligations.","category":"section"},{"location":"nodes/network/limitedflexibleinput/#nodes-limitedflexibleinput-math","page":"LimitedFlexibleInput","title":"Mathematical description","text":"LimitedFlexibleInput nodes extend the standard NetworkNode constraint set by introducing resource-specific limits on the input mix.","category":"section"},{"location":"nodes/network/limitedflexibleinput/#nodes-limitedflexibleinput-math-var","page":"LimitedFlexibleInput","title":"Variables","text":"Like all NetworkNodes, the following optimization variables are used:\n\ntextttopex_var \nVariable operating expenses.\ntextttopex_fixed \nFixed operating expenses.\ntextttcap_use \nActual operational use of the node in time t.\ntextttcap_inst \nInstalled capacity at time t.\ntextttflow_in \nFlow of resource p into node n at time t.\ntextttflow_out \nOutput flow of resource p at time t.\ntextttemissions_node if EmissionsData is added to the field data","category":"section"},{"location":"nodes/network/limitedflexibleinput/#nodes-limitedflexibleinput-math-con","page":"LimitedFlexibleInput","title":"Constraints","text":"The following sections omit the direct inclusion of the vector of LimitedFlexibleInput nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all LimitedFlexibleInput types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"section"},{"location":"nodes/network/limitedflexibleinput/#nodes-limitedflexibleinput-math-con-stand","page":"LimitedFlexibleInput","title":"Standard constraints","text":"LimitedFlexibleInput utilize in general the standard constraints that are implemented for a NetworkNode node as described in the documentation of EnergyModelsBase. These standard constraints are:\n\nconstraints_capacity:\ntextttcap_usen t leq textttcap_instn t\nconstraints_capacity_installed:\ntextttcap_instn t = capacity(n t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_out:\ntextttflow_outn t p =\noutputs(n p) times textttcap_usen t\nqquad forall p in outputs(n) setminus textCO_2\nconstraints_opex_fixed:\ntextttopex_fixedn t_inv = opex_fixed(n t_inv) times textttcap_instn first(t_inv)\ntip: Why do we use `first()`\nThe variable textttcap_inst is declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacity in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\ntextttopex_varn t_inv = sum_t in t_inv opex_var(n t) times textttcap_usen t times scale_op_sp(t_inv t)\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified data of the nodes, see above.\n\nThe function constraints_flow_in receives a new method to handle the input flow constraints:\n\nInput/output balance (normalized):\nsum_p in P^in fractextttflow_inn t pinputs(n p) =\ntextttcap_usen t\nThis constraint enforces a normalized energy balance between input resource flows and total utilized capacity.\nInput share constraint per resource:\ntextttflow_inn t p leq\nleft(sum_q in P^in textttflow_inn t qright) cdot limit(n p)\nThis constraint ensures that the contribution of resource p is limited to a maximum fraction defined in the limit field.","category":"section"}]
}
